% --------------------------------------------------------------------
% Preamble
% --------------------------------------------------------------------
\documentclass[paper=a4, fontsize=11pt,twoside]{scrartcl}   

\usepackage[a4paper,pdftex]{geometry}   
\setlength{\oddsidemargin}{5mm}           
\setlength{\evensidemargin}{5mm}

\usepackage[english]{babel}
\usepackage[protrusion=true,expansion=true]{microtype}    
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{float}
\usepackage{listings}
\usepackage{seqsplit}

\usepackage[draft]{graphicx}
%\usepackage{graphicx}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{ragged2e}
\usepackage{tabto}
\usepackage{afterpage}
\usepackage[usenames, dvipsnames]{color}
\usepackage{titlesec}
\usepackage{lipsum}
\usepackage{tipa}
\usepackage{amsthm}
\usepackage{relsize}
\usepackage{color}
\usepackage{chngcntr}
\usepackage{textcomp}
\usepackage[binary-units=true]{siunitx}
\numberwithin{table}{section}
\numberwithin{figure}{section}
\numberwithin{algorithm}{section}
\usepackage{url}
\usepackage{fancyhdr}
\usepackage{pgfplots}
\usetikzlibrary{pgfplots.groupplots}


% --------------------------------------------------------------------
% Definitions
% --------------------------------------------------------------------
\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}     

\makeatletter                            
\def\printtitle{%                        
    {\centering \@title\par}}
\makeatother                                    

\makeatletter                           
\def\printauthor{%                    
    {\large \@author}}                
\makeatother       

\newcommand\blankpage{%
    \null
    \thispagestyle{empty}%
    \addtocounter{page}{-1}%
    \newpage}                     

\definecolor{mygray}{gray}{0.6}

\titleformat{\section}
{\normalfont\huge\bfseries}
{\thesection\hskip 12pt\textcolor{mygray}{\textdoublepipe}\hskip 20pt}
{0pt}
{}

\titlespacing*{\section}{0pt}{18pt}{13pt}

\newtheorem{ddef}{Definition}[section]


\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{language=C++}
\lstset{
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
  morekeywords={uint32_t, int32_t, uint16_t},
  literate={~} {$\sim$}{1},
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE]{\leftmark}
\fancyhead[RO]{\rightmark}
\fancyfoot[LE,RO]{\thepage}

\fancypagestyle{firststyle}
{
   \fancyhf{}
   \fancyhead[L]{1 ~~\textsc{INTRODUCTION}}
}
% --------------------------------------------------------------------
% Metadata
% --------------------------------------------------------------------

\title{
	\begin{flushright}
		\LARGE{\textit{Scott Williams}}
	\end{flushright}
	~\\[2.0cm]			
	\HRule{0.5pt} \\                        
    \LARGE \textbf{\uppercase{Steganographic file systems within video files}}    
    \HRule{2pt} \\[30pt]        
	\normalsize \textsc{Computer Science Part II Project Dissertation}\\[2.0cm]     
    \normalsize Christ's College\\[5pt]University of Cambridge\\[25pt]           
    \normalsize \today            
}

\author{
    \begin{spacing}{1.5}
        \noindent
        \uppercase{Project Supervisor}: Daniel Thomas\\    
        \uppercase{Director of Studies}: Professor Ian Leslie\\    
        \uppercase{Project Overseers}: Professor Peter Robinson, Dr Robert Watson\\
    \end{spacing}
}


\begin{document}
\renewcommand{\thelstlisting}{\thesection.\arabic{lstlisting}}
\counterwithin{lstlisting}{section}
% ------------------------------------------------------------------------------
% Maketitle
% ------------------------------------------------------------------------------
\thispagestyle{empty}        

\printtitle                    
\vfill
\begin{center}
\huge{[~}\normalsize \textsc{Third Draft}\huge{~]}
\end{center}
\afterpage{\blankpage}
\newpage
% ------------------------------------------------------------------------------
% Begin document
% ------------------------------------------------------------------------------
\setcounter{page}{1}        
\pagenumbering{roman}
\section*{Proforma}
\thispagestyle{plain}
\NumTabs{3}
\textsc{Name}: \tab{Scott Williams}\\
\textsc{College}: \tab{Christ's}\\
\textsc{Project Title}: \tab{Steganographic file systems within video files}\\
\textsc{Examination}: \tab{Part II of the Computer Science Tripos}\\
\textsc{Year}: \tab{2015}\\
\textsc{Word Count}: \tab{13,758 (cut out 870)}\\
\textsc{Project Originator}: \tab{Scott Williams}\\
\textsc{Project Supervisor}: \tab{Daniel Thomas}\\

\subsection*{Original Aims of the Project}
To investigate appropriate steganographic embedding methods for video and to develop a practical steganographic software package to enable the embedding of arbitrary data within video files via a file system interface. Raw \texttt{AVI} video files should be supported and a variety of steganograhpic embedding algorithms should be available. Basic file system commands should work within the presented logical volume and embedding should occur with no perceivable impact on video quality. If time permits, multiple video formats should be supported along with encryption and plausible deniability functionality.

\subsection*{Work Completed}
A complete software package has been developed enabling the embedding of arbitrary files within multiple video formats via a file system interface. A native uncompressed \texttt{AVI} decoder has been implemented along with a generic method for dealing with other video formats. A total of 6 steganographic embedding algorithms are supported, along with encryption and plausible deniability functionality. Common file system operations work as expected within the mounted volume and the embedding process can operate without any perceivable impact on video quality as verified by a user study. The performance of the file system is adequate for general use achieving read and write speeds on par with some USB 3.0 flash drives.

\subsection*{Special Difficulties}
None.

\pagebreak
\thispagestyle{plain}

\section*{Declaration of Originality}
~\\[5pt]
I, Scott Williams of Christ's College, being a candidate for Part II of the Computer
Science Tripos, hereby declare that this dissertation and the work described
in it are my own work, unaided except as may be specified below, and that
the dissertation does not contain material that has already been used to any
substantial extent for a comparable purpose.

I give permission for my dissertation to be made available in the archive
area of the Laboratory's website.\\[20pt]
\textit{Signed:}\\[20pt]
\textit{Date:}
\clearpage

\thispagestyle{plain}
\tableofcontents
\thispagestyle{plain}
\vfill

\pagebreak

\section{Introduction}
\pagenumbering{arabic} 
\thispagestyle{firststyle}

Steganography is the art of hiding information in apparently inconspicuous objects. Whereas cryptography seeks to protect the content of information, steganography attempts to conceal the fact that the information exists\textsuperscript{\cite[pp. xv - xvi]{digmedia}}. This allows steganographic methods to be utilised in countries where encryption is illegal and identification of encrypted data can be grounds for imprisonment. Within the UK for example, keys for identified encrypted data can be forced to be disclosed\textsuperscript{\cite{uklaw}}, rendering standard cryptographic methods alone unfavourable.

In this project I design and implement a practical steganographic software application - \texttt{Stegasis} - which enables users to embed arbitrary files within video via a file system interface. \texttt{Stegasis} can operate with no perceivable impact on video quality and can provide very large embedding capacities. Multiple video formats are supported along with several steganographic embedding algorithms. Standard encryption algorithms can be used to further protect embedded data and plausible deniability functionality keeps sensitive information safe even when the presence of embedded data has been confirmed.

Steganogaphic methods operating on video have had comparatively little attention compared to other medium such as images and audio\textsuperscript{\cite[p. xvii]{digmedia}}. As such, there are few programs currently available which allow data to be steganographically hidden within video\textsuperscript{\cite{survey}}. \texttt{Stegasis} is the first application to enable the embedding of arbitrary files within videos via a file system interface.   

\subsection{Motivation}
Digital media is ubiquitous on the Internet and high definition video content is now common place on video sharing and social networking websites. Video files of multiple gigabytes in size can reside on users devices without arousing suspicion, providing an ideal hiding place for large collections of sensitive files. Few programs are capitalising on this fact, and those that are, allow the user to embed only a singe chosen file into a small range of video formats with very low embedding capacities. As with \texttt{TrueCrypt}\footnote{A successful widely used cryptographic program providing on-the-fly and full disc encryption\textsuperscript{\cite{truecrypt}}. Unfortunately, \texttt{TrueCrypt} is not longer being maintained.}, I believe that a practical system for protecting sensitive files should present the user with a mounted logical volume allowing the use of standard file system operations to create, access and organise embedded data. Furthermore, there exist many commonly used video formats along with many more currently in development. As such, a steganographic program operating on a small number of video formats not only greatly restricts usability, it will require constant development as new video formats inevitably become more popular. Instead, a generic solution applicable to a variety of video formats is preferred.

The recent global surveillance disclosures show the extent to which government authorities monitor online communications\textsuperscript{\cite{nsa}}. These, together with current UK laws mean it is no longer the case that simply encrypting data is enough to keep the owner safe.


\section{Preparation}
\subsection{Background}
The project aims to combine 3 main topics; steganography, video formats and file systems. Understanding of these will be required to develop a successful final product.\\

\noindent
The most important property of any steganographic system is undetectability, that is, it should be impossible to differentiate between ordinary and steganographically modified objects. This requirement is famously formulated within Simmons' prisoners' problem\textsuperscript{\cite{prisoner}}:

Alice and Bob are imprisoned in separate cells and wish to formulate an escape plan. They are allowed to communicate, but all messages must pass through a warden Eve. If Eve suspects the prisoners of secretly discussing their escape plan, the communication channel will be severed and Alice and Bob thrown into solitary confinement. The prisoners attempt to utilise steganograhpy to exchange details of their plan undetected. The steganographic system is considered broken if Eve is able to detect the presence of hidden messages within the prisoners exchanges. It is assumed that Eve has a complete knowledge of the steganographic algorithm being used, with the exception of the stego key, which Alice and Bob have agreed upon beforehand. This is in parallel with Kerckhoff's principle used within cryptography\textsuperscript{\cite{kirc}}. The warden can be considered to be one of three categories: \textit{passive}, \textit{active} and \textit{malicious}. A passive warden does not modify the exchanged messages in any way, whereas an active warden may modify the messages whilst maintaining their original meaning. For example replacing words with synonyms or reordering sentences. If images are being used as a transport medium then an active warden may recompress or crop the images. A malicious warden attempts to break the steganograhpic system and impersonate the prisoners in an attempt to obtain information.

This project is concerned only with the case of the passive warden. As such, any modification of the video files once \texttt{Stegasis} has embedded data within them, will most likely render the embedded file system corrupt. This unfortunately means utilising video sharing websites such as YouTube and Facebook for distribution is not possible due to them performing compression and transcoding upon video upload.

\subsubsection{Steganographic Concepts}
A \textit{steganographic system} will form a core part of the final application, allowing requested data to be hidden within video. A steganographic system depends on the following components:
\begin{itemize}
	\item A \textit{Cover object} is the original object that the message will be embedded within. A cover object consists of a number of \textit{elements}, for example pixels.
	\item A \textit{Message} is an arbitrary length sequence of symbols. For this project we consider messages of the form $\mathcal{M} \in \{0,1\}^{8 \cdot n} $ for some $n$ - a sequence of bytes.
	\item A \textit{Stego key} is a secret key used within the embedding process.
	\item A \textit{Stego object} is the result of embedding a message inside a cover object.
\end{itemize}

\begin{ddef}
\textsc{Steganographic System}\\[5pt]
Let $\mathcal{C}$ be the set of all cover objects. For a given $\textbf{c} \in \mathcal{C}$, let $\mathcal{K} _{\textbf{c}}$ denote the set of all stego keys for \textbf{c}, and the set $\mathcal{M} _{\textbf{c}}$ denote all messages that can be communicated in \textbf{c}. A steganographic system\footnote{This is specifically steganography by cover modification.} is then formally defined as a pair of embedding and extracting functions Emb and Ext,
\begin{center}
	Emb :  $\mathcal{C} \times \mathcal{K} \times \mathcal{M} \rightarrow \mathcal{C}$\\
	Ext :  $\mathcal{C} \times \mathcal{K} \rightarrow \mathcal{M}$\\
\end{center}
satisfying,
\begin{center}
	$\forall ~\textbf{c} \in \mathcal{C}, \textbf{k} \in \mathcal{K}_{\textbf{c}}, \textbf{m} \in \mathcal{M}_{\textbf{c}}.$ Ext(Emb(\textbf{c}, \textbf{k}, \textbf{m}), \textbf{k}) = \textbf{m}	
\end{center}
\end{ddef}
\begin{ddef}
\textsc{Embedding Capacity}\\[5pt]
The \textit{Embedding Capacity} (payload) $\mathcal{P} _{\textbf{c}}$ for a given cover object \textbf{c} $\in \mathcal{C}$ is defined in bits as,
\begin{center}
	$\mathcal{P} _{\textbf{c}} = \log_{2}|\mathcal{M}_{\textbf{c}}| $
\end{center}
The relative embedding capacity $\mathcal{R} _{\textbf{c}}$ for a given cover object \textbf{c} $\in \mathcal{C}$ is defined as,
\begin{center}
	$\mathcal{R} _{\textbf{c}} = \dfrac{\log_{2}|\mathcal{M}_{\textbf{c}}|}{n} $
\end{center}
where n is the number of elements in \textbf{c}.
\end{ddef}
\noindent
For example, consider $\mathcal{C}$ to be the set of all 512 $\times$ 512 greyscale images, embedding one bit per pixel gives $\mathcal{M} = \{0,1\}^{512 \times 512}$ and $\forall ~\textbf{c} \in \mathcal{C}. ~|\mathcal{M}(\textbf{c})| = 2^{512 \times 512}$. The embedding capacity $\forall ~\textbf{c} \in \mathcal{C}$ is then $512 \times 512 \approx 33$kB as expected. In this case, $n$ is equal to the number of pixels in \textbf{c} and therefore the relative embedding capacity is equal to 1 bpp (bits per pixel), again as expected.

Using the definitions above, we can define a simple expression for the embedding capacity of a video file. 
\begin{ddef}
\textsc{Embedding Capacity for video}\\[5pt]
With $\mathcal{C}$ as the set of all video files, the embedding capacity $\mathcal{V} _{\textbf{c}}$ for a given video $\textbf{c} \in \mathcal{C}$ can be expressed as,
\begin{center}
	$\mathcal{V} _{\textbf{c}} ~= \mathlarger{\mathlarger{\sum}}\limits_{f ~\in ~\textnormal{frames}(\textbf{c})} \mathcal{P} _{f}$
\end{center}
\end{ddef}
\noindent
Note that for certain embedding algorithms, the embedding capacity can depend on both the input data and the cover object\footnote{Many algorithms operating on \texttt{JPEG} images for example will not embed within zero valued DCT coefficients.}. However, in some cases the following expression is also valid,
\begin{center}
	$\mathcal{V} _{\textbf{c}} ~=~ |\text{frames}(\textbf{c})| \cdot \mathcal{P} _{f _{0}}$
\end{center}
\pagebreak
\begin{ddef}
\textsc{Steganographic Capacity}\\[5pt]
The concept of Steganographic Capacity is loosely defined as the maximum number of bits that can be embedded within a given cover object without introducing statistically detectable artifacts. % <-- spelt right
\end{ddef}
\noindent
For completeness, the least significant bit (LSB) of a given number is defined as follows,
\begin{center}
	LSB($x$) = $x \mod 2$
\end{center}

\noindent
It will be useful to visually inspect the effect of steganographic embedding algorithms operating on the LSBs of pixels. The \textit{LSB Plane} of an image is therefore defined.

\begin{ddef}
\textsc{LSB Plane}\\[5pt]
The Least Significant Bit Plane of a given image $\mathcal{\textbf{c}}$ and a specified colour channel $q$ is defined as the 1 bit image $\textnormal{LSBP}(\mathcal{\textbf{c}},q)$ which has resolution equal to that of image $\mathcal{\textbf{c}}$ and with pixel values  $\textnormal{LSBP}(\mathcal{\textbf{c}},q)(x,y)$ given by,
\begin{center}
	$\textnormal{LSBP}(\mathcal{\textbf{c}},q)(x,y) = \textnormal{LSB}(\mathcal{\textbf{c}}(x,y))$
\end{center} 
\end{ddef}


\subsubsection{Steganalysis}
Steganalysis is the study of detecting messages embedded using steganographic techniques; this is analogous to cryptanalysis applied to cryptography\textsuperscript{\cite{steganalysis}}. A steganalysis attack is considered successful (that is, the steganography has been broken) if it is possible to correctly distinguish between cover and stego objects with probability better than random guessing. Note that it is not necessary to be able to read the contents of the secret message to break a steganographic system.

A trivial example of steganalysis arises when the steganalyst has access to the original cover object used within the embedding procedure. By computing the difference between the stego and cover objects, the steganalyst can immediately detect the presence of a hidden message. This attack identifies a number of important points to consider when developing a practical steganographic system. Firstly, embedding within popular media content should be discouraged, as the cover object will likely be widely available. Secondly, if a user is embedding within original content, for example a video recorded by them, any copies of the original file should be securely erased after embedding.

Steganalysis methods can be split into two main categories, \textit{Targeted Steganalysis} and \textit{Blind Steganalysis}. Targeted Steganalysis occurs when the steganalyst has access to the details of the steganographic algorithm used for embedding. The steganalyst can accordingly target their activity to the specific stegosystem. On the other hand, if the steganalyst has no knowledge of the utilised steganographic algorithm, Blind Steganalysis techniques must be applied. In this project, Targeted Steganalysis attacks are developed for several of the proposed embedding algorithms.

\subsubsection{The AVI file format}
\label{avi}
As specified within the project proposal, this project initially looks at raw uncompressed \texttt{AVI} files. Furthermore, only \texttt{AVI} version 1.0\footnote{Not including the Open-DML extension (version 1.02).} files are investigated and therefore supported natively\footnote{All other video formats (including compressed \texttt{AVI}) are supported via the use of \texttt{FFmpeg}, as described in Section \ref{extffmpeg}.} by \texttt{Stegasis}. Unfortunately, uncompressed \texttt{AVI} is today, a very uncommon video format\textsuperscript{\cite{avicommon}}. This is likely due to its relatively huge file sizes when compared to a modern compressed format such as \texttt{H.264}. For example, one minute of 720p HD footage encoded as uncompressed \texttt{AVI} is roughly 4.2 GB.

The \texttt{AVI} file format is a Resource Interchange File Format (\texttt{RIFF}) file specification developed by Microsoft and originally introduced in November 1992\textsuperscript{\cite{aviformat}}. The data within \texttt{RIFF} files is divided into chunks and lists, each of which is identified by a \texttt{FourCC} tag. An \texttt{AVI} file takes the form of a single chunk in a \texttt{RIFF} formatted file, which is then subdivided into two mandatory lists, the \texttt{hdrl} and \texttt{movi} and one optional chunk, the \texttt{idxl}. The second sub-list contains the actual audio/video data and will be where steganographic embedding will occur. See the Appendix Section \ref{app:avi} for detailed definitions of the data structures used.

An \texttt{AVI} file consists of a number of data streams (usually 2, one for audio and one for video) interleaved within the \texttt{movi} list.
Each stream has a corresponding \texttt{AVI} stream header and format chunk within the above mentioned \texttt{hdrl} list. These data structures contain information about the stream including the codec and compression used (if any). Specifically, the \texttt{fccHandler} field contains a \texttt{FourCC} tag that identifies a specific data handler. For raw uncompressed video this will equal `DIB ' (Device Independent Bitmap). Any user provided \texttt{AVI} files with a \texttt{fccHandler} not equal to `DIB ', (compressed video) will at this point be rejected and an error message presented to the user.

The \texttt{movi} list contains the raw video and audio data within sequential \texttt{RIFF} chunks. Each chunk for the DIB video stream contains one frames worth of pixel data, with each pixel represented by a 3 byte BGR (Blue Green Red) triple - a total of 24 bits per pixel. The first 3 byte triple corresponds to the lower left pixel of the final image\footnote{This can be inverted via a flag within the \texttt{BITMAPINFOHEADER}.}. 

If we use an embedding algorithm which embeds 3 bits per pixel (1 bit per colour channel per pixel), we can derive a simple expression for the embedding capacity of an uncompressed \texttt{AVI} video \textbf{c}, in terms of the height $h$ and width $w$ in pixels and the total number of frames $t$:

\begin{center}
	$\mathcal{V} _{\textbf{c}} = 3 \cdot w \cdot h \cdot t$
\end{center}

\noindent
These values are all available within the \texttt{AVIMAINHEADER} structure allowing the user to be informed of the video's total embedding capacity upon formatting.

\subsubsection{JPEG compression}
\label{jpeg}

The \texttt{JPEG} file format will prove useful when developing a universal steganographic technique operating across many video formats (Section \ref{extffmpeg}). Steganography within the \texttt{JPEG} format has had a comparatively large amount of attention from the research community\textsuperscript{\cite{jpegsteg}}. As such, there exists a fair number of well documented steganographic embedding algorithms for \texttt{JPEG}\textsuperscript{\cite{jsteg} \cite{f5} \cite{outguess}}.

The \texttt{JPEG} compression process consists of 5 main procedures:
\begin{enumerate}
	\item Transform the image into an optimal color space. 
	\item Downsample chrominance components by averaging groups of pixels together.
	\item Apply a \textit{Discrete Cosine Transform} (DCT) to blocks of pixels. 
	\item Quantise each block of DCT coefficients using a quantisation table. 
	\item Encode the resulting coefficients using a Huffman variable word-length algorithm. 
\end{enumerate}

\noindent
Note that step 4 is an example of lossy compression, whereas step 5 is lossless. Therefore most steganographic algorithms will operate on the quantised DCT coefficients (between steps 4 and 5) to avoid embedded data being lost due to quantisation.

Conveniently, the Independent JPEG Group provide the \texttt{libjpeg} C library\textsuperscript{\cite{libjpeg}} which will abstract the complexities of the \texttt{JPEG} format and allow direct access to the quantised DCT coefficients prior to step 5 being executed.

\texttt{JPEG} DCT coefficients are arranged into several components containing \textit{rows} which contain a number of \textit{blocks}. Each block contains 64 coefficients ranging from $-2048$ to $2047$. A \texttt{JPEG} will usually have 3 components corresponding to the \textit{Luminance and Chrominance} colour model (\texttt{YCbCr}) with the first component being luma and the remaining two being the blue-difference and red-difference chroma components. Since human perception is more sensitive to changes in luminance compared to colour\textsuperscript{\cite{sensitive}}, steganographic embedding will usually not occur within the luminance component.

It is worth noting that the \texttt{JPEG} decompression and compression processes are computationally expensive. This is especially important when dealing with video since a 3 minute music video, for example, consists of around 4,500 frames (which can be considered as individual \texttt{JPEGs}). Since performance of the virtual file system is important, design decisions will need to be made to avoid any unnecessary compression and decompression operations. Also worth noting is that although \texttt{JPEG} files are small on disk, they are not once decompressed into memory. It will not be possible to hold all 4,500 decompressed \texttt{JPEG} frames of an average 3 minute video in memory.

\subsubsection{FFmpeg}
\label{ffmpeg}

\texttt{FFmpeg} is an open source, multimedia framework\textsuperscript{\cite{ffmpeg}}. It is a ``complete, cross-platform solution to record, convert and stream audio and video''. In particular, it contains codecs for nearly every video format available today\textsuperscript{\cite{ffmpegcodec}}.  

The pitfalls of the uncompressed \texttt{AVI} video format, as discussed in Section \ref{avi}, show that \texttt{Stegasis} would greatly benefit from operating on multiple video formats. I could continue to investigate more video formats and develop parsers for these as part of the project. However, this will become a very time consuming endeavor most likely resulting in very brittle, untested parsers. Instead, it would be wise to leverage the \texttt{FFmpeg} framework for this functionality.

One trivial solution to allow \texttt{Stegasis} to operate on multiple video formats would be to convert all user provided video files to uncompressed \texttt{AVI} prior to the embedding process. However, this doesn't solve the problems of the huge file sizes and uncommonality of the uncompressed \texttt{AVI} format.

A novel solution to this problem is posed in Section \ref{extffmpeg} and makes use of \texttt{FFmpeg} to convert input files to the \textit{Motion \texttt{JPEG}} file format.

\subsubsection{Developing a file system}
\label{fs}

A file system can either operate within \textit{kernel} or \textit{user space}. I decided within the project proposal to develop the file system component for \texttt{Stegasis} in user space using the \texttt{FUSE} (Filesystem in Userspace) library\textsuperscript{\cite{fuse}}. This was primarily because developing a kernel module is complex and hard to test - a segmentation fault occurring within kernel space code will bring down the entire machine. A kernel module also requires a large amount of boiler plate code and I would prefer to spend time on the steganographic portion of this project rather than getting bogged down with the complexities of a kernel file system implementation. In contrast, \texttt{FUSE} ships with an example ``hello world'' file system which is less than 100 lines of C code. Also, developing the file system in user space will cause the final application to be a lot more portable and easier for users to install - a kernel space file system would require super user permission to load the related kernel module.

There are however disadvantages to using a file system in user space, performance being one of them\textsuperscript{\cite{fuseper}}. This is due to the \texttt{FUSE} kernel module having to act as a proxy between the system call and the user space code.

\begin{figure}[here]
\centerline{\includegraphics[width=0.8\textwidth]{images/fuse_structure.png}}
\caption{Path of a file system call in \texttt{FUSE}, taken from \url{fuse.sourceforge.net}.}
\label{fig:fuse}
\end{figure}

Figure \ref{fig:fuse} shows the path of a file system call in the provided hello world example file system. We can see the \texttt{FUSE} kernel module acting as a proxy between the \texttt{VFS} system call and the \texttt{example/hello} user space code. A kernel space file system would not need to re-enter user space to complete the system call, hence giving better performance. 

The \texttt{FUSE} library provides a number of function definitions which the user space code implements. These functions are then called when the corresponding file system operation occurs.

\begin{lstlisting}[language=C, caption={\texttt{FUSE} read operation.}, frame=single]
int read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi);
\end{lstlisting}

\noindent
The \texttt{read} function is called when a file system read occurs. It requests that \texttt{size} bytes of the file \texttt{path} starting at offset \texttt{offset} should be written to the buffer \texttt{buf}.

\subsection{Existing tools}
\label{tools}
The relatively little work on steganography within video was reflected in my search for steganographic programs operating on video files. This section contains an exhaustive list of all the video steganogrphy tools I could find freely\footnote{A further 2 programs exist claiming to embed within video, however these are closed source and not freely available to download. Therefore they have been excluded from this list. (Info Stego, Hiderman)} available on the Internet. A total of 6 tools claimed to provide steganographic embedding functionality within video files. Of these 6, only 3 actually attempt to embed within the video data itself. None of the identified programs allow the user to embed more than one file\footnote{Admittedly you could embed a compressed archive using these tools to effectively allow a directory structure to be embedded.}  and none of them provide any sort of file system interface.

\subsubsection{StegoStick}

\texttt{StegoStick}\textsuperscript{\cite{stegostick}} claims to allow users to ``hide any file into any file''. This statement suggests that the program is simply appending the requested file to the end of the cover object. This suspicion is partly true; based on the file extension, \texttt{StegoStick} splits cover objects into 3 categories: images, media and other. The other category does indeed just append the file to the cover object, whereas the image and media category do attempt to employ steganographic embedding methods. The images category applies to files with extensions \texttt{JPG}, \texttt{GIF} and \texttt{BMP} and uses LSB embedding within \texttt{BMP} files (other image formats are converted to \texttt{BMP} prior to embedding). The media category applies to \texttt{WAV}, \texttt{AVI} and \texttt{MPG} files and assumes each format has a ``header'' of 44+55 bytes\footnote{Listed in the source as ``44 byte header + 54 bytes of extension space''.}. Although this seems to be true for the \texttt{WAV} format, this is not the case for \texttt{AVI} nor \texttt{MPG} files. \texttt{StegoStick} will then use blind LSB embedding within the remaining data. As such, my attempts to use \texttt{StegoStick} to embed within \texttt{AVI} files rendered the resulting video unplayable. % (I haven't actually done this...) 

\subsubsection{StegoMagic}

\texttt{StegoMagic}\textsuperscript{\cite{stegomagic}} claims to ``work on all types of files and all size of data'' which again sounds as though it's appending the file to the end of the cover object. This is indeed the case, embedding an image within a video and inspecting the modified file shows that data has just been appended to the end of the video, albeit encrypted. \texttt{StegoMagic} does not specify the encryption algorithm used and the source code is not available to view. Furthermore, the user cannot specify an encryption key to use. Instead, \texttt{StegoMagic} generates a 5 digit number during the embedding process and presents this to the user.  

\subsubsection{TCSteg}

\texttt{TCSteg}\textsuperscript{\cite{tcsteg}} is a Python script accompanying a blog post written by Martin Fiedler discussing hiding \texttt{TrueCrypt} volumes within \texttt{MP4} files. The method described embeds the \texttt{TrueCrypt} volume within the \texttt{MP4} atom \texttt{mdat} and modifies the chunk offset table within the \texttt{moov} atom so that any application playing the video will ignore the embedded data. A nice property of \texttt{TCSteg} is that the resulting video file can be directly mounted by \texttt{TrueCrypt} since it ignores the \texttt{MP4} header data prior to the embedded volume.\\

\noindent
The above programs all resort to embedding within video files by either appending the embedded data to the end of the video, or inserting the embedded data at some point within the video file. I do not consider this approach to embedding data secure, and it should be a trivial task for any steganalyst to detect the presence of embedded data within the stego objects using a simple hex editor. Therefore, the above stegosystems should be considered broken and definitely not used for the hiding of sensitive data.

\subsubsection{StegoVideo}

\texttt{StegoVideo}\textsuperscript{\cite{stegovideo}} is a Virtual Dub filter\footnote{Which is also available in a stand alone executable form.} which allows users to embedded a file within \texttt{AVI} files (supporting multiple compression codecs). I am unsure of the exact steganograhpic embedding algorithm used since the program is closed source, but the website does mention that \texttt{StegoVideo} makes use of error correction codes to allow embedded data to be recovered even after the resulting video has been compressed - although this is understandably dependant on the compression amount. \texttt{StegoVideo} attempts to protect the embedded data via the use of a 5 digit number, although as with \texttt{StegoMagic}, this is not provided by the user and is instead generated and presented to the user.

\subsubsection{OpenPuff}

\texttt{OpenPuff}\textsuperscript{\cite{openpuff}} is a steganographic tool supporting a wide range of formats, including \texttt{3GP}, \texttt{MP4}, \texttt{MPG} and \texttt{VOB}. It allows users to embed a file within a collection of carrier objects and uses 3 user provided passwords to encrypt, scramble and whiten (mixing with a high amount of noise) the provided file. Plausible deniability is also provided via the option to add decoy content. \texttt{OpenPuff} successfully embedded and retrieved a text file within a sample \texttt{MP4} video and I could notice no perceivable impact on video quality. Performance was also good due to multithreading support. However, the embedding capacity is very limited. A hard limit of \SI{256}{\mega\byte} is imposed regardless of the number and size of the carrier objects and I was only able to achieve embedding capacities of around 0.0043\%\footnote{2,600 bytes within a \SI{60}{\mega\byte} video.} even at the maximum capacity setting. This makes \texttt{OpenPuff} impractical for hiding large files - for example, you would need around 770 \SI{60}{\mega\byte} \texttt{MP4} carrier files to embed a standard \SI{2}{\mega\byte} \texttt{JPEG} image.

\subsubsection{Steganosaurus}

\texttt{Steganosaurus}\textsuperscript{\cite{steganosaurus}} is a cross platform steganograhpic program developed by James Ridgway. It allows users to embed a file within \texttt{H264} video files via the modification of motion vectors. Two embedding algorithm variants are provided and the input file is encrypted using \texttt{AES} with a user provided passphrase. A modified version of \texttt{FFmpeg} was used to access and modify the motion vectors, these modifications have not yet been open sourced. I unfortunately could not get \texttt{Steganosaurus} to run on my computer (using Linux or Windows) and therefore could not test its operation.\\

\noindent
The above 3 programs are much more promising from a steganogrphic security point of view and some of them also support multiple video formats. However, all feature the same limitation of only allowing the user to embed one chosen file and the offered embedding capacities are far from practical for use with large files.

This project aims to remedy these issues by allowing the user to embed an arbitrary number of files within a video (via a file system interface) and by providing high capacity steganographic embedding algorithms (for example 15\% of the video size)\footnote{This is very much a trade off - larger embedding capacities will come at the sacrifice of steganogrphic security. However, this decision is presented to the user rather than decided by the program itself and sensible defaults will be put in place.}. 

\subsection{Requirements Analysis}

After reviewing the necessary background material and investigating current available solutions to the problem of steganography within video, I produced the following collection of requirements. For the project to be a success, all of the core requirements should be fulfilled.

\subsubsection{Core Requirements}

\texttt{Stegasis} should:

\begin{enumerate}
\item Allow users to embed data within video files:
	\begin{enumerate}
		\item Several steganographic embedding algorithms should be available.
		\item Each embedding algorithm, $\mathcal{A}$, should satisfy correctness. That is,
		\begin{center}
			$\forall ~\textbf{c}, \textbf{k}, \textbf{m}. ~Ext_{\mathcal{A}}(Emb_{\mathcal{A}}(\textbf{c}, \textbf{k}, \textbf{m}), \textbf{k}) = \textbf{m}$.
		\end{center}
		\item Embedding should occur with no perceivable impact on video quality.
		\item Steganalysis tools should be developed to test the security of the proposed embedding algorithms.
		\item An optional user provided password should encrypt data prior to embedding.
		\item A capacity flag should allow users to specify the percentage of each video frame to embed within.
	\end{enumerate}
\item Provide a file system interface:
	\begin{enumerate}
		\item The presented logical volume should reside at a user provided mount point.		
		\item Data written to the file system should be embedded on the fly within the chosen video file.
		\item Data accessed from the file system should be extracted on the fly from within the video.
		\item Standard file system operations such as creating, deleting and moving files should work as expected, and standard Unix tools such as \texttt{cp}, \texttt{mv} and \texttt{rm} should also work as expected.
	\end{enumerate}	
\item Support raw uncompressed \texttt{AVI} video:
	\begin{enumerate}
		\item Uncompressed \texttt{AVIs} should be natively decoded allowing access to individual pixel data.
	\end{enumerate}	
\item Provide adequate file system performance:
	\begin{enumerate}
		\item Full HD video content should be playable directly from within the presented file system (bitrates of full HD video are roughly 8 - 12 Mb/s\textsuperscript{\cite{bitrate}}).
		\item Ideally, the file system should provide read and write speeds comparable to those provided by USB 2.0 devices\footnote{Although the USB 2.0 standard supports speeds of up to 480 Mb/s, devices rarely reach this theoretical limit.}(roughly 20 MB/s\textsuperscript{\cite{usb2}}).
	\end{enumerate}		
\end{enumerate}

\subsubsection{Possible Extensions}

If time constraints allow, the following extension tasks shall also be completed.\\

\noindent
\texttt{Stegasis} should:

\begin{enumerate}
\item Support embedding within multiple video formats.
\item Allow directory operations within the file system:
	\begin{enumerate}
		\item Creating directories using the \texttt{mkdir} command should work as expected, as should using the \texttt{mv} and \texttt{rm} commands.
		\item Organising files within directories should also work as expected.
	\end{enumerate}	
\item Embed also within audio data:
	\begin{enumerate}
		\item Data should also be embedded within the (possible) audio stream of the video, therefore increasing the embedding capacity.
	\end{enumerate}	
\item Provide plausible deniability:
	\begin{enumerate}
		\item A second file system should be (optionally) embedded within the video, mountable with a second passphrase.
		\item The presence of the second, hidden file system should not be detectable.
	\end{enumerate}
\item Be evaluated for perceivable video impact using an evaluation study:
	\begin{enumerate}
		\item A developed web application should evaluate the requirement ``Embedding should occur with no perceivable impact on video quality.'' by obtaining data from multiple users.
	\end{enumerate}		
\end{enumerate}

\subsection{Choice of Languages and Tools}

With the above requirements for the final product defined, an appropriate set of programming languages and tools can be identified. 

\texttt{Stegasis} will be designed to operate on the \texttt{Linux} operating system since \texttt{Windows} has no equivalent of the file system in user space paradigm.

Several of the core (and extension) requirements strongly suggest a lower level language such as C or C++ rather than a higher level sandboxed language such as Java. For example, the parsing and modification of \texttt{AVI} files lends itself to a language like C since it will involve large amounts of byte level manipulation. Furthermore, the Microsoft file format reference defines the different data structures used within \texttt{AVIs} as C \texttt{structs}. \texttt{FUSE}, \texttt{libjpeg} and libraries provided by \texttt{FFmpeg} are all natively C libraries. Although wrappers for other languages (including Java) do exist\textsuperscript{\cite{javafuse} \cite{turbojpeg}}, they seem to be lacking documentation and few are being actively maintained. The requirement that \texttt{Stegasis} should support several steganographic embedding algorithms implores the use of object oriented techniques; defining a \texttt{Steganographic Algorithm} interface of which each embedding algorithm implements. This suggests C++ over C. The final core requirement, performance, also favours C/C++ over Java\footnote{Numerous studies have shown that C/C++ code performs better than equivalent Java code\textsuperscript{\cite{javaper1} \cite{javaper2} \cite{javaper3}}.} due to the JVM overheads. 

The reasons above and the fact I have prior experience using C++ led to the conclusion that C++ should be the primary language used to develop \texttt{Stegasis}.

As discussed in Section \ref{ffmpeg}, \texttt{FFmpeg} will be used for the extension task ``\texttt{Stegasis} should support a wide range of video formats'', to allow the decoding and conversion of the many video formats available today, together with library \texttt{libjpeg} discussed in Section \ref{jpeg} for the manipulation of \texttt{JPEG} images. 

During the implementation of \texttt{Stegasis}, a number of small steganalysis programs will be developed. These will likely be written in a scripting language such as Python or Matlab since both have extensive library support for mathematical operations.

The extension task ``\texttt{Stegasis} should be evaluated for perceivable video impact using a web application'' will require a web application to be developed and hosted for easy access to participants and a database to store the collected user data. \texttt{Node.js} together with the web application framework \texttt{Express} and the database \texttt{MongoDB} was chosen as the development stack for the site. This decision was mainly due to the speed at which you can develop \textit{CRUD} (create, read, update and delete) web applications - essentially what this evaluation site is - and my previous experience with the technologies.

\vfill

\pagebreak
\section{Implementation}

\subsection{Introduction}

The development of \texttt{Stegasis} consisted of the five main stages detailed within this chapter. Firstly, a parser for the \texttt{AVI} file format as discussed in Section \ref{avi} was developed allowing direct access to video pixel data. Next, steganographic embedding algorithms were implemented along with corresponding steganalysis tools to test the security of the proposed techniques. The file system was then developed utilising the \texttt{AVI} decoder and steganogrphic algorithms to embed and extract data directly into and out of video files. Finally, the extension tasks were individually addressed providing support for multiple video formats, directory structures and plausible deniability.\footnote{The evaluation site extension task is discussed within the evaluation chapter.} The testing section provides an overview of the testing processes applied throughout development. 

The software development process embraced the modern ``Launch early, iterate often'' methodology\textsuperscript{\cite{iterate}}. A simplified version of \texttt{Stegasis} was initially produced allowing integration issues to be identified early on, when the code was still very malleable. Once this basic version was working, an iterative approach was then taken to add more functionality and features.

\subsection{AVI Decoder}
\label{avidec}

The concept of an \texttt{AVI} decoder is first abstracted to that of a generic \texttt{Video Decoder} interface\footnote{The term ``interface'' is used as shorthand for an abstract C++ base class. That is, a class with pure virtual member functions and no function implementations.}. The core requirements state that the \texttt{AVI} decoder should allow access to individual pixel data. The pixel data within an \texttt{AVI} file is grouped into chunks, one per video frame. This lead to the decision to define the \texttt{Video Decoder} to allow access to the video pixel data at a granularity of a single video frame. It will also be useful for the \texttt{Video Decoder} interface to expose metadata about the video, for example, the total number of video frames in the video, the height and width of the video frames and the total size (in bytes) of each video frame.

This gives the definition for the \texttt{Video Decoder} interface as described in Listing \ref{viddec} (\texttt{NextFrameOffset} will be discussed in Section \ref{fsi}).

\begin{lstlisting}[language=C++, caption={\texttt{Video Decoder} interface (\texttt{video/video\_decoder.h:15})},frame=single, float,floatplacement=H,label=viddec]
class VideoDecoder {
  public:
    virtual Frame *getFrame(int frame) = 0;
    virtual int getFileSize() = 0;
    virtual int getNumberOfFrames() = 0;
    virtual int getFrameSize() = 0;
    virtual int getFrameHeight() = 0;
    virtual int getFrameWidth() = 0;

    virtual void getCapacity(char capacity) = 0;
    virtual void setCapacity(char capacity) = 0;        
    
    virtual void getNextFrameOffset(int *frame, int *offset) = 0;
    virtual void setNextFrameOffset(int frame, int offset) = 0;
   	   
    virtual void writeBack() = 0;
    virtual ~VideoDecoder() {};
};
\end{lstlisting}

Note that \texttt{getFrame} returns a \texttt{Frame} wrapper object, rather than a raw \texttt{char} pointer to the frame pixel data, adhering to the \textit{Dependency Inversion} principle\textsuperscript{\cite{inver}}. This will be useful when dealing with different video formats that don't necessarily group all of a frames video data to be accessible by a single \texttt{char} pointer.

A \texttt{Frame} abstracts the concept of a single frames video data. In the case of uncompressed \texttt{AVI}, this can be thought of as a \texttt{char} pointer to the GBR pixel data, along with an associated frame size in bytes. A boolean value is also associated with each chunk, signifying if the chunk data has been modified, that is, it is dirty. The \texttt{Frame} interface is defined in Listing \ref{frame}.

\begin{lstlisting}[language=C++, caption={Frame interface (\texttt{video/video\_decoder.h:4})}, frame=single, label=frame]
class Frame {
  protected:
    long frameSize;
  public:
    virtual long getFrameSize() = 0;
    virtual char *getFrameData(int n=0, int c=0) = 0;
   
    virtual bool isDirty() = 0;
    virtual void setDirty() = 0;
};
\end{lstlisting}

\noindent
Note that the parameters for \texttt{getFrameData} are optional. For the \texttt{AVI} decoder, these will not be used.

The \texttt{AVI} parsing process can be thought of consisting of two main parts; parsing the video headers and parsing the video chunk data. The pseudocode in Algorithm \ref{parseavi} illustrates this with the headers being parsed lines 1-12 and the chunks being parsed lines 15-22. See the Appendix Section \ref{app:code} for some longer code samples.

\begin{algorithm}[!h]
\caption{\texttt{AVI} parsing process}
\label{parseavi}
\begin{algorithmic}[1]
\State f $\gets$ open(file\_path)
\State riff\_header $\gets$ readRiffHeader(f)
\If{riff\_header.fourCC != RIFF}
	\State Error ``File is not an AVI file"
\EndIf
\State avi\_header $\gets$ readAviHeader(f)
\State bitmap\_info\_header $\gets$ readBitmapInfoHeader(f)
\If{bitmap\_info\_header.compression != 0}
	\State Error ``Stegasis does not natively support compressed AVI files''
\EndIf
\State audio\_info\_header $\gets$ readAudioInfoHeader(f)
\State frame\_chunks $\gets$ [ ]
\State i $\gets$ 0
\Comment{File pointer is now positioned at the start of the audio video chunks} 

\While{i $<$ avi\_header.total\_frames}
	\State chunk $\gets$ readChunk(f)
	\If{chunk is a video chunk}
		\State frame\_chunks[i].chunkSize = chunk.chunkSize
		\State frame\_chunks[i].frameData = readChunkData(f)
		\State i ++
	\Else
		\State Advance f chunk.chunkSize bytes
	\EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

The actual implementation is slightly more complex than presented above due to the existence of \texttt{JUNK} chunks. The \texttt{AVI} file format specifies that any number of chunks with a \texttt{FourCC} code of \texttt{JUNK} and of arbitrary length can be inserted between any \texttt{AVI} list structures. The parser must therefore be able to cope with this.

The \texttt{WriteBack} function of the \texttt{AVI} decoder will write back any modified \texttt{Frame} data into the original \texttt{AVI} file. This operation is described in Algorithm \ref{writeback} below.

\begin{algorithm}[!h]
\caption{\texttt{AVI} write back process}
\label{writeback}
\begin{algorithmic}[1]
\State Seek f to the chunks offset
\State i $\gets$ 0
\While{i $<$ avi\_header.total\_frames}
	\State chunk $\gets$ readChunk(f)
	\If{chunk.fourCC == 00db}
		\If{frame\_chunks[i].isDirty}
			\State Write frame\_chunks[i].frameData to f
			\State frame\_chunks[i].dirty = false
			\Comment{This chunk is no longer dirty}
		\Else
			\State Advance f chunk.chunkSize bytes
			\Comment{Chunk did not need to be written}
		\EndIf
		\State i ++
	\Else
		\State Advance f chunk.chunkSize bytes
		\Comment{Chunk was not a video chunk}
	\EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

\texttt{getFrameSize} returns the number of bytes within each frame that should be embedded within and is shown in Listing \ref{framesize}.

\begin{lstlisting}[language=C++, caption={\texttt{AVI} decoder \texttt{frameSize} function (\texttt{video/avi\_decoder.cc:298})}, frame=single, label=framesize]
virtual int frameSize() {
  return (int)floor(this->aviHeader.width * this->aviHeader.height * 3 * (this->capacity / 100.0));
};
\end{lstlisting}

This expression arises from the fact that uncompressed \texttt{AVI} uses 24 bits per pixel value. Since there are $height \cdot width$ pixels within a single frame, multiplying this by 3 will give the total number of bytes. \textit{Capacity} is a user provided percentage ranging in value from 1 - 100. It specifies the percentage of the frame to embed within. \texttt{frameSize} must therefore reduce the returned frame size value by ``capacity percent''.

The effect of the capacity parameter is illustrated within Figure \ref{cap50}. The top left image is the original video frame and the top right image is the LSB plane (red channel) of the frame with no data embedded. The bottom two images have data sequentially embedded within them using capacity settings of 50\% and 15\% respectively.


\begin{figure}[!h]
\centerline{\includegraphics[width=\textwidth]{images/cap_ill.png}}
\caption{Illustration of the capacity parameter.}
\label{cap50}
\end{figure}

\noindent
The image used throughout this chapter for illustration purposes has been specifically chosen to emphasise the effect of the embedding process. Due to post processing applied to the video, the LSB plane closely resembles that of the original frame. This would not be the case for a video recorded on a phone for example.

The \texttt{AVI} decoder as described now provides all necessary functionality to allow the modification of pixel data to achieve the steganogrphic embedding of information within video frames. 


\subsection{Steganographic Algorithms}

As defined within the previous section, a steganogrphic system consists of a pair of functions providing embedding and extraction functionality. Therefore, a generic \texttt{Steganographic Algorithm} interface will need to declare two functions \texttt{embed} and \texttt{extract} which will embed and extract data into and out of cover objects. Listing \ref{stegoalg} shows the interface.

\begin{lstlisting}[language=C++, caption={\texttt{Stego Algorithm} interface (\texttt{steg/steganographic\_algorithm.h:8})}, frame=single, label=stegoalg]
class SteganographicAlgorithm {
  protected:
    string password;
    VideoDecoder *dec;
  public:
    virtual pair<int, int> embed(Frame *f, char *data, int reqByteCount, int offset) = 0;
    virtual pair<int,int> extract(Frame *f, char *output, int reqByteCount, int offset) = 0;
    virtual void getAlgorithmCode(char out[4]) = 0;
};
\end{lstlisting}

\noindent
The \texttt{embed} function attempts to embed \texttt{reqByteCount} bytes from \texttt{data} into frame \texttt{f} starting at an offset \texttt{offset} bytes into the frame and returns the number of bytes successfully embedded along with the reached frame offset. Similarly, the \texttt{extract} function attempts to extract \texttt{reqByteCount} bytes from frame \texttt{f} starting at an offset \texttt{offset} bytes into the frame and put them into \texttt{output} and returns the number of bytes successfully extracted along with the reached frame offset.

\texttt{getAlgorithmCode} returns a 4 character algorithm identifier which is used when users specify which algorithm they want to use.\\

\subsubsection{LSB Sequential Embedding}

Sequential LSB embedding is arguably the simplest steganographic algorithm. It works by replacing the LSBs of the cover object with the bits comprising the message, producing the stego image. Algorithm \ref{lsbalg} shows pseudocode for the LSB embedding algorithm. The matching extraction algorithm is shown in Algorithm \ref{lsbext}.

\begin{algorithm}[!h]
\caption{LSB embedding algorithm}
\label{lsbalg}
\begin{algorithmic}[1]
\For{i $\gets$ 0 upto dataBytes - 1}
	\For{j $\gets$ 7 downto 0}
		\If{The jth significant bit of data[i] == 1}
			\State Set LSB(frame[offset++]) to 1
		\Else
			\State Set LSB(frame[offset++]) to 0
		\EndIf
	\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htb]
\caption{LSB extraction algorithm}
\label{lsbext}
\begin{algorithmic}[1]
\For{i $\gets$ 0 upto dataBytes - 1}
	\For{j $\gets$ 7 downto 0}
		\State Set the jth significant bit of output[i] to LSB(frame[offset++]) 
	\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\noindent
Listing \ref{lsbimp} shows the actual implementation and Figure \ref{lsbill} illustrates the algorithms operation.  

\begin{lstlisting}[language=C++, caption={LSB embedding implementation (\texttt{steg/lsb\_algorithm.cc:8})}, frame=single, label=lsbimp]
virtual pair<int,int> embed(Frame *f, char *data, int reqByteCount, int offset) {
  this->crypt->encrypt(data, reqByteCount);
  char *frame = f->getFrameData();
  int bytesEmbedded = 0;
  while (bytesEmbedded<reqByteCount && offset<this->dec->getFrameSize()) {
    for (int j = 7; j >= 0; j --) {
      if ((((1 << j) & data[bytesEmbedded]) >> j) == 1) {
        frame[offset++] |= 1;
      } else {
        frame[offset++] &= ~1;
      }
    }
    bytesEmbedded ++;
  }  
  this->crypt->decrypt(data, reqByteCount);
  if (offset == this->dec->getFrameSize()) {
    return make_pair(bytesEmbedded, 0);    
  } else {
    return make_pair(bytesEmbedded, offset);  
  }
};
\end{lstlisting}

\begin{figure}[!htb]
\centerline{\includegraphics[width=\textwidth]{images/lsb_ill.png}}
\caption{Illustration of the LSB Embedding algorithm, taken from \url{forensicmag.com}}
\label{lsbill}
\end{figure}

\noindent
Using the LSB embedding algorithm, \SI{43.2}{\kilo\byte} of data is is embedded into a single 1280 $\times$ 720 video frame (using a capacity setting of 100\%). The resulting stego image is shown in Figure \ref{lsbemb_full}, with the left image being the cover object and the right image the stego object.

\vfill

\begin{figure}[!h]
\centerline{\includegraphics[width=\textwidth]{images/lsb_emb_full.png}}
\caption{Effect of the LSB Embedding algorithm.}
\label{lsbemb_full}
\end{figure}

\noindent
The visual impact on the video frame is very small and almost certainly not noticeable having been reproduced within this document at a smaller resolution. However, if we take a closer look at a specific portion of the video frame, we can see some small discrepancies between the cover and stego objects - see Figure \ref{lsbcloseup}. I am unsure how well these images will be reproduced when printed, but the difference is definitely noticeable within the \texttt{PDF}. Without the original cover object for comparison, it would be very hard to identify these details visually and deduce the presence of embedded data. However, if the LSB plane of the frame is visually inspected, as in Figure \ref{lsbemb}, one can immediately detect the presence of the hidden data - the LSB plane of the stego object looks ``too random''. This is an example of a \textit{visual steganalysis attack}.


\begin{figure}
\centerline{\includegraphics[width=0.9\textwidth]{images/closeup_3.png}}
\caption{Close up effect of the LSB Embedding algorithm.}
\label{lsbcloseup}
\end{figure}


\begin{figure}
\centerline{\includegraphics[width=0.9\textwidth]{images/lsb_emb.png}}
\caption{LSB plane of the cover and stego object.}
\label{lsbemb}
\end{figure}

Formalising the looking ``too random'' idea leads to the \textit{Chi-Squared attack} developed by Westfeld and Pfitzmann\textsuperscript{\cite{chi}}. To implement the Chi-Squared attack, the concept of \textit{Pair of Values} (PoVs) is introduced.

One of the effects of an embedding algorithm like sequential LSB embedding is the creation of POVs, pixel values that embed into one another. For example, a pixel value of 100 in the cover image will either stay 100 or change to 101. Similarly, a pixel value of 101 will either stay 101 or change to 100. Thus (100, 101) is a POV. 

\begin{ddef}
\textsc{Pairs of Values}\\[5pt]
A POV $\textbf{p}$ is a member of the set $\mathcal{P}ov$, defined as,
\begin{center}
$\mathcal{P}ov \triangleq \{~(2k, 2k + 1) ~\vert ~ 0 \leq k \leq 127 ~\}$
\end{center}
\end{ddef}

\noindent
Westfeld and Pfitzmann claim that the LSBs in images are not completely random, rather, the frequencies of each of the two pixel values in each POV tend to lie far from the mean of the POV. That is, it is unlikely for the frequency of pixel value $2k$ to be close to equal to the frequency of pixel value $2k+1$. Furthermore, as information is embedded into the cover object, the frequencies of $2k$ and $2k+1$ become (nearly) equal. The Chi-squared attack was designed to detect this and bases the probability of embedding on how close to equal POVs are in the image.

\pagebreak
To implement the attack, the following steps are taken in reference to a given image. First, $x_{k} =$ frequency($2k$) and $y_{k} =$ frequency($2k+1$) are calculated, followed by the expected frequency $z_{k} = \dfrac{x_{k} + y_{k}}{2}$ $~\forall ~k$. $n$ is defined to be the number of POVs, $\vert \mathcal{P}ov \vert$. For uncompressed \texttt{AVI} using 24 bits per pixel, $n=128$. The \textit{minimum frequency condition} is now applied. This sets $x_{k} = y_{k} = z_{k} = 0$ and decrements $n$ by one, if the condition $x_{k} + y_{k} \leq 4$ holds. The Chi-Squared statistic, with $n - 1$ degrees of freedom is then calculated:
\begin{center}
$\chi ^{2} _{n-1} = \mathlarger{\sum}\limits_{k=0}^{127} \dfrac{(x_{k} - z_{k})^2}{z_{k}}$
\end{center}

\noindent
The probability of embedding, $p$, is then calculated by evaluation of the following integral:
\begin{center}
$p = 1 - \dfrac{1}{2^{\frac{n-1}{2}} \Gamma (\frac{n-1}{2})} \mathlarger{\int}_{0}^{\chi ^{2} _{n-1}} e^{-\frac{u}{2}}u^{\frac{n-1}{2}-1} du$
\end{center}

\noindent
See Appendix Section \ref{app:chi} for an implementation of the Chi-squared attack in Python.\\

\noindent
The Chi-squared attack produces very good results for the na\"ive sequential LSB embedding algorithm. Figure \ref{chi} show an example of it in use operating on a video frame with a capacity setting of 50\%. It obvious that information has been embedded within the first half of the frame.\\

\begin{figure}[here]
\centerline{\includegraphics[width=\textwidth]{images/chi_graph.png}}
\caption{Results of the Chi-Squared attack.}
\label{chi}
\end{figure}

\noindent
The Chi-Squared attack motivates the development of a \textit{permuted} LSB embedding algorithm. The attack works so well because regardless of the capacity setting, the data is sequentially embedded from the top of the video frame. It would be better to distribute the data uniformly throughout the entire frame. A permuted LSB embedding algorithm achieves this and resists the Chi-Squared attack when using a small capacity setting\footnote{A permuted embedding using a capacity of 100\% is no different to sequential embedding!}.

\subsubsection{Permuted LSB Embedding}

One can produce deceptively simple pseudocode for the permuted LSB embedding algorithm as shown in Algorithm \ref{lsbp}.

\begin{algorithm}[!h]
\caption{Permuted LSB embedding algorithm}
\label{lsbp}
\begin{algorithmic}[1]
\State path $\gets$ a pseudorandom permutation of the cover object
\State path.seekToOffset(offset-1)
\For{i $\gets$ 0 upto dataBytes - 1}
	\For{j $\gets$ 7 downto 0}
		\If{The jth significat bit of data[i] == 1}
			\State Set LSB(frame[path.next()]) to 1
		\Else
			\State Set LSB(frame[path.next()]) to 0
		\EndIf
	\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\noindent
Lines 1 and 2 hide a large amount of complexity involved in implementing the algorithm.

Assuming the cover object consists of $n$ bytes, a pseudorandom permutation of the cover object can be thought of as a pseudorandom permutation of the numbers 0 - $n$. One way to produce a pseudorandom permutation of a list of numbers is to shuffle an array containing them. This approach has the drawback that you need to hold the numbers in memory (\SI{11}{\mega\byte} for a single 720p HD video frame). Instead, I took a different approach using a \textit{Linear Congruential Generator}\textsuperscript{\cite{lcg}} (LCG).

\begin{ddef}
\textsc{Linear Congruential Generator}\\[5pt]
A Linear Congruential Generator is defined by the recurrence relation:
\begin{center}
$X_{n+1} = (aX_{n} + c) \mod m$
\end{center}
where $X$ is the sequence of pseudorandom values, and
\begin{center}
$m, ~0 < m$ - the modulus\\
$a, ~0 < a < m$ - the multiplier\\
$c, ~0 \leq c < m$ - the increment\\
$X_{0}, ~0 \leq X_{0} < m$ - the seed
\end{center}
are integer constants that specify the generator.
\end{ddef}

\noindent
The pseudorandom permutation is only needed to uniformly distribute embedding throughout the image and it is therefore not a problem that a LCG may not produce cryptographically secure random numbers. The Hull-Dobell Theorem\textsuperscript{\cite{hull}} states that a LCG will have a full period if and only if the following 3 requirements are satisfied:
\begin{enumerate}
	\item $gcd(c, m) = 1$ ($c$ and $m$ are relatively prime),
	\item $a-1$ is divisible by all prime factors of $m$,
	\item $a-1$ is a multiple of 4 if $m$ is a multiple of 4.
\end{enumerate}

\noindent
Therefore, if the above requirements can be satisfied, a LCG can be used as a pseudorandom permutation for the cover object with $m$ equal to $n$ (the size of the cover object). Note that forcing $m$ to be a power of 2, simplifies the above requirements to:
\begin{enumerate}
	\item $gcd(c, m) = 1$,
	\item $a-1$ is odd,
	\item $a-1$ is a multiple of 4 if $m$ is a multiple of 4.
\end{enumerate}

\noindent
As such, $m$ is set equal to the next power of 2 larger or equal to $n$. Any produced values larger or equal to $n$ are just discarded, therefore producing a full period of size $n$ as required.

The pseudorandom permutation should be dependant on a user provided passphrase. Therefore, the values of $a$ and $c$ are determined using a key derived from the users passphrase. The popular key derivation function \texttt{PBKDF2}\textsuperscript{\cite{keyd}} is used along with the \texttt{Whirlpool}\textsuperscript{\cite{pool}} hash function to generate a 128 byte key pool and the first 4 bytes are taken as an unsigned integer and used to derive $c$ and $a$. Rather than implement these well known algorithms myself, I used a popular C++ cryptographic library, \texttt{Crypto++}.\\

\noindent
The result of the permuted embedding algorithm is illustrated in Figure \ref{lsbp_ill}. The left image has data embedded using the sequential embedding algorithm whereas the right image has the same data embedded using the permuted embedding algorithm. Both images were using a capacity setting of 15\%.

\begin{figure}[here]
\centerline{\includegraphics[width=\textwidth]{images/lsbp_ill.png}}
\caption{Illustration of the permuted LSB algorithm.}
\label{lsbp_ill}
\end{figure}

Figure \ref{lsbp_chi} shows the result of applying the Chi-Squared attack to the video frames in Figure \ref{lsbp_ill}. The left and right graphs show the probability of embedding within the left and right frame respectively. It is clear that the implemented permuted LSB embedding algorithm resists the Chi-Squared attack when using small values for the capacity setting. 

\begin{figure}[here]
\centerline{\includegraphics[width=\textwidth]{images/lsbp_chi.png}}
\caption{Chi-Squared attack on the permuted LSB algorithm.}
\label{lsbp_chi}
\end{figure}

\noindent
The above example embedded data within an uncompressed \texttt{AVI} video file which was 10 seconds in duration, had a resolution of $1280\times720$ and was \SI{741}{\mega\byte} in size. Using the permuted LSB embedding algorithm with a capacity setting of 15\% (which resisted the Chi-Squared attack), \texttt{Stegasis} informed me that the formatted volume had a total capacity of \SI{14.49}{\mega\byte}, roughly 2\% of the file size. This embedding capacity is already a lot better than some of the those provided by programs investigated in Section \ref{tools}, and will be further improved upon during the extension task within Section \ref{extffmpeg}.

\subsubsection{Encrypting the embedded data}

To further strengthen the security of \texttt{Stegasis}, I decided to encrypt the data before embedding it within the video. This way, even if the stegosystem is broken, the information itself will not be compromised. The available cryptographic algorithms are decoupled from the steganogrphic systems allowing the user to mix and match between them. In addition, the same user provided passphrase used to permute the data throughout the video frame is used within the encryption process\footnote{A different section of the 128 bytes key pool is used.}, addressing another concern of some of the investigated programs in Section \ref{tools}.\\

\noindent
The initial approach to encrypt the embedded data was to simply \texttt{XOR} it with a pseudorandom number stream. The \texttt{Crypto++} library provides a variety of suitable pseudorandom number generators which can be seeded. However, questions about the cryptographic strength of these number generators lead to the implementation of more standard encryption algorithms and the eventual removal of the pseudorandom number stream option. \texttt{AES} (256 bit), \texttt{TwoFish} and \texttt{Serpent} are all available within the \texttt{Crypto++} library which made incorporating them in \texttt{Stegasis} easy. Counter mode (\texttt{CTR}) is used as the block cipher mode so that data is not required to be padded to the block size. A hybrid chained encryption scheme \texttt{AES} $\rightarrow$ \texttt{TwoFish} $\rightarrow$ \texttt{Serpent} is also supported. This method has the advantage that if even 2 of the above algorithms are cryptographically broken, the data will still be secure\footnote{This encryption option is also offered by \texttt{TrueCrypt}.}. You do however incur a performance penalty due to the encryption and decryption processes.\\


\noindent
This concludes the steganogrphic embedding algorithms developed to satisfy the core requirements operating on uncompressed \texttt{AVI} video. Table \ref{totalalgs} shows a complete list of the implemented steganographic and cryptographic algorithms, including those implemented within the extension tasks (in italics). Although I have shown resistance to some steganalysis techniques, I have no doubt that there exist attacks that would break these implemented stego systems. However, more secure steganogrphic systems are investigated within the extension tasks and the framework \texttt{Stegasis} provides allows easy incorporation of new, more secure embedding algorithms.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|lll}
\cline{1-2}
\textbf{Steganographic (Algorithm code)} & \textbf{Cryptographic} \\ \cline{1-2}
LSB Embedding (\texttt{LSB}) & AES   \\ \cline{1-2}
Permuted LSB embedding (\texttt{LSBP}) & Serpent \\ \cline{1-2}
\textit{DCT LSB embedding (\texttt{DCT})} & TwoFish  \\ \cline{1-2}
\textit{Permuted DCT LSB embedding (OutGuess 0.1) (\texttt{DCTP})} & AES(Serpent(TwoFish)) \\ \cline{1-2}
\textit{F4 (\texttt{F4})} & \\ \cline{1-2}
\textit{F5 (\texttt{F5})} & \\ \cline{1-2}
\end{tabular}
\caption{Implemented steganographic and cryptographic algorithms}
\label{totalalgs}
\end{table}


\subsection{The File system}
\label{fsi}

I decided early on that the file system would only support a subset of the features offered by a fully-fledged standard file system. The following features were considered essential for a bare-bones practical file system: Creating and deleting files, reading and writing to files, listing the files in the file system and renaming (moving) files. Support for directories was also considered important and was therefore implemented as an extension task.

File permissions and access / modification times were considered non-essential and therefore not implemented. This means all files will be given the same permissions of \texttt{755} (\texttt{RWXRW-RW-}), and all access / modification times default to 0 \textit{Unix Time} (1 January 1970).

Since the file system functionality was being implemented from scratch, the code written turned out complex and intricate due to the many corner cases encountered during integration testing. A large amount of time was dedicated to testing the implemented file system and tracking down particularly nasty concurrency bugs arising in specific circumstances.\\

\noindent
The basic idea behind storing a file system within a video is to develop some kind of header which contains the locations of all of the files stored across the video frames. The files themselves will be broken into arbitrary sized \textit{chunks} and stored within a particular frame at a particular offset. Consider the following example use case which motivates the solution developed in this section. A 10 byte text file is first written to the volume and embedded within frame 1 of the video at offset 0. A second file is now written to the volume and is such embedded within frame 1 at offset 80.\footnote{Since it takes 8 bytes of frame to embed 1 byte of data.} Now, additional text is appended to the first file, where should this be embedded? The obvious answer is after the second file, thus requiring some sort of header to keep track of the chunks so that the files can be read back correctly.

\subsubsection{Developing the header}

The header serves a similar purpose to the \textit{File Allocation Table} used with the \texttt{FAT} file systems. It will need to be stored in a known location so that it can be extracted when the video file is mounted. I decided to use the first frame of the video to store the header; referred to as the \textit{File Allocation Frame} (\texttt{FAF}). The design of the header went through a number of iterations before arriving at the final version presented here, mainly due to underestimating the number of bits needed to store the file frame numbers and offsets. Figure \ref{header} shows the overall structure of the \texttt{FAF}.

\begin{figure}[!h]
\centerline{\includegraphics[width=\textwidth]{images/header.png}}
\caption{File allocation frame structure.}
\label{header}
\end{figure}

\noindent
The header section (coloured blue) contains metadata about the embedded file system. ``STEG'' is the literal 4 character \texttt{ASCII} string and is used to check the header has been correctly extracted. If STEG is not found as the first 4 bytes of the header, the extraction process is aborted and an error message displayed to the user. The ``Header Bytes'' field contains the number of remaining bytes to be extracted from the \texttt{FAF}. This data contains information for each of the files within the file system, including the file name as a null terminated string, the number of chunks the file is split into and the location and size of each of these chunks. A file chunk is represented as a \texttt{FileChunk} struct defined in Listing \ref{triple}.

\begin{lstlisting}[caption={FileChunk definition (\texttt{fs/stegfs.h:19})}, frame=single, label=triple]
struct FileChunk {
  uint32_t frame;
  uint32_t offset;
  uint32_t bytes;
};
\end{lstlisting}

\noindent
Within Figure \ref{header}, a single file chunk is indicated with square brackets, and is coloured green. A file can contain an arbitrary number of chunks each of which can span multiple frames. Note that using an unsigned integer for the struct fields limits individual chunk sizes to roughly \SI{4}{\giga\byte}. However, this shouldn't be a problem since writes to the file system occur in 65 kB chunks.

\subsubsection{Writing to the file system}

A write to the file system occurs in three main stages. First, \texttt{create} will be called requesting that a new file be created with a specified name. Next, the \texttt{write} function will be called a number of times requesting that data be written to the file. Finally \texttt{flush} will be called for the file requesting that any data held in memory be flushed to disk.

The first stage is easy to implement and is listed in Listing \ref{create}.

\begin{lstlisting}[language=C++, caption={The \texttt{create} function call (\texttt{fs/stegfs.cc:202}).}, frame=single, label=create]
int SteganographicFileSystem::create(const char *path, mode_t mode, struct fuse_file_info *fi) {
  this->fileSizes[path] = 0;
  this->fileIndex[path] = std::vector<struct FileChunk>();
  return 0;
};
\end{lstlisting}

\noindent
The write calls are a bit trickier, recall the \texttt{FUSE} write call which requests that \texttt{size} bytes from the buffer \texttt{buf} should be written to the file \texttt{path} starting at offset \texttt{offset}. Algorithm \ref{write} shows pseudocode for the write function. The full implementation is listed in the Appendix Section \ref{app:coderead}.

\begin{algorithm}[!h]
\caption{Writing to the file system.}
\label{write}
\begin{algorithmic}[1]
\State bytes\_written $\gets$ 0
\State (next\_frame, next\_offset) $\gets$ decoder.getNextFrameOffset()
\State chunk $\gets$ FileChunk()
\While{bytes\_written $<$ size}
	\State (bytes\_embedded, new\_offset) = embed size-bytes\_written from buf+bytes\_written into next\_frame at next\_offset
	\State chunk.bytes += bytes\_embedded
	\State next\_offset = new\_offset
	\If{new\_offset == 0}
		\State next\_frame ++
	\EndIf
	\State bytes\_written += bytes\_embedded
\EndWhile
\State fileIndex[path].append(chunk)
\State return size
\end{algorithmic}
\end{algorithm}



Finally, \texttt{flush} is called which will write the header and ask the video decoder to write back to disk. This can either occur synchronously or asynchronously depending on a user specified flag.

\subsubsection{Reading from the file system}

The read function call is similar, recall the declaration which requests that \texttt{size} bytes of the file \texttt{path} starting at offset \texttt{offset} should be written to the buffer \texttt{buf}. The read function must identify the chunk \texttt{offset} points to and then return the correct amount of data possibly spread across multiple subsequent chunks. Algorithm \ref{read} describes the function operation. See the Appendix Section \ref{app:coderead} for the full implementation.

\begin{algorithm}[!htb]
\caption{Reading from the file system.}
\label{read}
\begin{algorithmic}[1]
\State bytesWritten $\gets$ 0, chunkNum $\gets$ 0, bytesWritten $\gets$ 0
\For{chunk in fileChunks}
	\If{bytesRead + chunk.bytes $>$ offset}
		\State break
	\Else
		\State bytesRead += chunk.bytes
		\State chunkNum ++
	\EndIf
\EndFor
\While{bytesWritten $<$ size}
	\State chunk $\gets$ fileChunks[chunkNum]
	\State bytesLeftInChunk $\gets$ chunk.bytes - chunkOffset
	\State bytesLeftInChunk $\gets$ min(bytesLeftInChunk, size-bytesWritten)
	\State extract(chunk.frame, chunk.offset + chunkOffset, bytesLeftInChunk, buf+bytesWritten)
	\State bytesWritten += bytesLeftInChunk
	\State chunkOffset $\gets$ 0
	\State chunkNum ++
\EndWhile
\end{algorithmic}
\end{algorithm}

\subsubsection{Listing files in the file system}

The function \texttt{readdir} is called when the contents of a directory are requested to be listed, the implementation is straightforward and just iterates of the fileSizes map as shown in Listing \ref{readdir}.\\

\begin{lstlisting}[language=C++, caption={\texttt{FUSE} readdir implementation (\texttt{fs/stegfs.cc:264}).}, frame=single, label=readdir,upquote=true]
int SteganographicFileSystem::readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi) {
  filler(buf, '.', NULL, 0);
  filler(buf, '..', NULL, 0);
  for (auto kv : this->fileSizes) {
    filler(buf, kv.first.c_str() + 1, NULL, 0);
  }
  return 0;
};
\end{lstlisting}

\noindent
The above \texttt{FUSE} operations cover the majority of the core file system implementation, successfully implementing all of the decided essential features listed at the start of this subsection.

\subsection{Command line application}

To complete \texttt{Stegasis}, the implemented components must be assembled together and a user interface produced. I decided on a command line interface allowing the user to utilise the functionality developed within this project. Listing \ref{stegasisrun} shows the process of formatting and mounting a video using \texttt{Stegasis}.

\begin{lstlisting}[caption={Using \texttt{Stagasis} to format and mount a video.}, frame=single, label=stegasisrun]
$ stegasis format -alg=lsbp -crypt=aes -pass=123 -cap=25 ~/my_video.avi
Formatting video...
Volume size: 30 MB
Format Successful
$ stegasis mount -alg=lsbp -crypt=aes -pass=123 ~/my_video.avi /mnt/video
Video mounted at /mnt/video
\end{lstlisting}

At this point, the user can copy files into \texttt{/mnt/video} and they will be automatically embedded within the video. The user can unmount the video by closing the program (for example by pressing Control-C), \texttt{Stegasis} will gracefully exit, writing back any unflushed changes to disk. See the Appendix Section \ref{app:steg} for more detailed usage information.

\texttt{Stegasis} works exactly how I envisioned it during the project inception. The example usage I gave within the project proposal is exactly reflected within the finished product\footnote{With the exception of pressing Control-C to exit rather than typing \texttt{stegasis unmount}.}.

\subsection{Extension Tasks}

All of the extension tasks listed within the project proposal were addressed and with the exception of ``Hiding data within audio streams'', all of them were successfully implemented. The further extension task ``Plausible deniability'' was added during the project and also successfully implemented.

\subsubsection{Supporting multiple video formats}
\label{extffmpeg}

As discussed, there are several reasons why it would be beneficial for \texttt{Stegasis} to operate on video formats other than uncompressed \texttt{AVI}. To accomplish this, rather than develop many video decoders and steganographic systems for multiple video formats, a generic solution was designed and implemented utilising \texttt{FFmpeg}.

Regardless of the video format, a video can be thought of as a sequence of video frames played back at a specific frame rate together with an optional audio track. Using \texttt{FFmpeg} to extract the frames of a video and implementing steganographic systems operating on sequences of images, \texttt{Stegasis} can function seamlessly across multiple video formats. For example, if a user provides a compressed \texttt{h.264} video, \texttt{FFmpeg} will extract each frame as a \texttt{JPEG} along with the audio track as an \texttt{mp3}. \texttt{Stegasis} will then embed and extract data into and out of the extracted \texttt{JPEG} images. When the video is unmounted, the modified images will be re-muxed as a \textit{Motion JPEG} stream together with the audio to produce an \texttt{MKV} file - the stego object. The \texttt{JPEG} file format was chosen for the intermediate frames due to the large number of steganographic algorithms operating on them. Figure \ref{multi} shows an overview of the approach.

\begin{figure}[!htb]
\centerline{\includegraphics[width=0.9\textwidth]{images/multi.png}}
\caption{Operation on multiple video formats.}
\label{multi}
\end{figure}

This method will work with virtually any video format presented to \texttt{Stegasis} due to the extensive codec library of \texttt{FFmpeg}. 

Although the initial conversion of the provided video to \texttt{JPEG} images can be lossy, the reassembly of video frames and extraction thereafter cannot - this would damage the embedded file system. This constraint leads to the following four \texttt{FFmpeg} commands shown in Listing \ref{ffmpegcmd}.

\begin{lstlisting}[caption={\texttt{FFmpeg} frame extraction and reassembly command.}, frame=single, label=ffmpegcmd,upquote=true]
// Convert an arbitrary video to JPEG images (Lossy)
ffmpeg -r <fps> -i <path> -qscale:v 1 -f image2 /tmp/stegasis/image-%d.jpg
// Extract video audio
ffmpeg -i <path> /tmp/stegasis/audio.mp3

// Losslessly convert modified JPEG images to an MJPEG stream
ffmpeg -framerate <fps> -i /tmp/stegasis/image-%d.jpg -i /tmp/stegasis/audio.mp3 -codec copy -shortest output.mkv

// Losslessly extract JPEGs from a video already formatted by Stegasis
ffmpeg -r <fps> -i <path> -vcodec copy /tmp/stegasis/image-%d.jpg
\end{lstlisting}


The first frame extraction command converts each frame of the video file to a \texttt{JPEG} image using the highest quality setting and writes them to \texttt{/tmp/stegasis/}. The reassembly command muxes the modified video frames and audio together into a single \texttt{MKV} file. The use of \texttt{-codec copy} tells \texttt{FFmpeg} to literally copy the \texttt{JPEGs} into a Motion JPEG (\texttt{MJPEG}) stream. This ensures the frames are not recompressed - preserving the embedded data. This process was verified to be correct by noting the \texttt{MD5} hash of the \texttt{JPEG} frames prior to being muxed. These frames were then extracted from the resulting \texttt{MKV} file, their hashes computed and compared. The second frame extraction command uses \texttt{-vcodec copy} which tells \texttt{FFmpeg} to losslessly extract each \texttt{JPEG} image from the \texttt{MJPEG} stream - preserving the embedded file system.

Using the above commands, I implemented a video decoder performing the described method. When \texttt{Stegasis} is run, a check occurs to see whether the provided file is an uncompressed \texttt{AVI}. If it is, the native \texttt{AVI} decoder developed is used. If it is not, this video decoder is used, allowing \texttt{Stegasis} to operate seamlessly across all video types without the user needing to manually specify which video decoder to use.\\

\noindent
The final step of this extension task is to implement embedding algorithms operating on the extracted \texttt{JPEG} images. Due to the design of \texttt{Stegasis}, by implementing the new algorithms satisfying the \texttt{Steganographic Algorithm} interface, all of the file system logic will continue to work as expected.

The implemented algorithms all embed data within the least significant bits of the \texttt{JPEGs} discrete cosine transform coefficients. As with the core project, several versions of the basic algorithm were implemented along with more advanced algorithms such as \texttt{F4} and \texttt{F5}. Algorithm \ref{jpegalg} shows pseudocode for the basic embedding algorithm.

\begin{algorithm}
\caption{Basic \texttt{JPEG} embedding algorithm.}
\label{jpegalg}
\begin{algorithmic}[1]
\For{i $\gets$ 0 upto data\_bytes - 1}
	\For{j $\gets$ 7 down to 0}
		\State (row, block, coefficient) $\gets$ getCoefficientForOffset(offset++)
		\State component = 2
		\Comment{Components 2 and 3 are the chroma components.}
		\State row $\gets$ frame.getRow(row, component)
		\If{ The jth significant bit of data[i] == 1}
			\State Set LSB(row[block][coefficient]) to 1
		\Else
			\State Set LSB(row[block][coefficient]) to 0
		\EndIf
	\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

Within the actual implementation, the component to embed within is chosen using the calculation \texttt{(co \% 2) + 1}. This uniformly distributes the embedded data bits between the two chroma components, deliberately not touching the luminance component. 

At higher capacity settings, this embedding algorithm does begin to produce visual artifacts within the video frames. Figure \ref{jpegarti} illustrates this when a capacity setting of 100\% is used.

\begin{figure}[!h]
\centerline{\includegraphics[width=\textwidth]{images/bb_100cap.png}}
\caption{Embedding artifacts at 100\% capacity.}
\label{jpegarti}
\end{figure}

However, at lower capacity settings it is not possible to visually differentiate between the cover and stego objects\footnote{This claim is verified within the evaluation Section \ref{security}.}. Roughly, any capacity setting above 50\% begins to introduce visually detectable artifacts. Figure \ref{jpegnoart} shows the same frame as above, but using a capacity setting of 20\%. (Left image is the original frame.)

\begin{figure}[!h]
\centerline{\includegraphics[width=\textwidth]{images/bb_20cap.png}}
\caption{Frame comparison at 20\% capacity.}
\label{jpegnoart}
\end{figure}

The basic \texttt{JPEG} embedding algorithm and the permuted variant (\texttt{OutGuess 0.1}) are both vulnerable to the \textit{histogram attack} discussed in Section \ref{security}. This motivates the implementation of more advanced algorithms such as \texttt{F4} and \texttt{F5} which resist this type of steganalysis attack. Instead of replacing the LSB of DCT coefficients, \texttt{F5} decrements the coefficients absolute value via \textit{matrix encoding}. This results in no pairs of values being produced and thus \texttt{F5} cannot be detected by the Chi-Squared attack. Matrix encoding within \texttt{F5} uses \textit{Hamming codes} to embed a k-bit message into a $2^k -1$ bit code word, changing it at most by one bit. This allows \texttt{F5} to achieve high embedding efficiencies. See the Appendix Section \ref{app:f5} for more details and an implementation of \texttt{F5}.\\
 
\noindent 
Due to the final lossless stage of \texttt{JPEG} compression, it can in some cases\footnote{This is highly dependant on the data being embedded. The best possible scenario is embedding all zeros.} be possible to embedded files larger than the cover object - achieving embedding capacities in excess of 100\%. This is because the encoding effectively compresses the embedded data before it is written back to disk. To show this in action, Listing \ref{200cap} shows a 306 MB file embedded within a 189 MB video.

\begin{lstlisting}[language=bash,caption={Demonstration of 162\% embedding capacity.}, frame=single, label=200cap]
$ ls -lah
-rw-rw-r-- 1 scott scott 189M Jan 15 22:30 video.mkv
$ stegasis mount -alg=dctl video.mkv /mnt/video
[...]
Mounting...
$ ls -lah /mnt/video
total 4.0K
drwxr-xr-x  2 root root    0 Jan  1  1970 .
drwxrwxrwt 12 root root 4.0K Jan 15 22:26 ..
-rwxr-xr-x  1 root root 306M Jan  1  1970 file1
\end{lstlisting}

\noindent
The performance of \texttt{Stegasis} operating on \texttt{JPEG} images is noticeably slower compared to uncompressed \texttt{AVI} files. This is due to the necessary decompressing and recompressing of the \texttt{JPEG} frames. As mentioned in the preparation section, it is not possible to hold all of the decompressed \texttt{JPEG} frames in memory, meaning they will need to remain compressed, only being decompressed when requested. Initially, the \texttt{JPEG} files were left on disk and read into memory and decompressed when requested before being recompressed and written back. This understandably gave terrible performance due to the large amount of disk IO. This was rectified by reading all of the compressed \texttt{JPEG} images into memory upon video mount. The decompression and recompression operates could then operate on this memory - no longer involving any disk IO.\\

\noindent
The above described additions to \texttt{Stegasis} allow it to seamlessly operate across a large range of video formats, greatly increasing practicality and successfully completing the extension task.

\subsubsection{File system directory structures}

The core implementation of the file system does not allow the creation and manipulation of directories, forcing all files written to the volume to reside in the root. Although \texttt{Stegasis} is still usable with this limitation, it would be nice to allow users to organise their embedded files using directories as you would expect from a normal file system. To achieve this, the \texttt{mkdir} \texttt{FUSE} operation will need to be implemented along with a few changes made to the current file system implementation.

A third data structure, \texttt{dirs} is first added along side \texttt{fileSizes} and \texttt{fileIndex} containing each of the directories within the file system. The \texttt{mkdir} operation is then trivial to implement as shown in Listing \ref{dir}.

\begin{lstlisting}[caption={\texttt{FUSE} mkdir implementation (\texttt{fs/stegfs.cc:158}).}, frame=single, label=dir]
int SteganographicFileSystem::mkdir(const char *path, mode_t mode) {
  this->dirs.insert(path);
  return 0;
}
\end{lstlisting}

The \texttt{readdir} implementation will need to be modified to correctly list the files with respect to the current working directory. It is no longer correct to just iterate over all files in the file system and return their names since you only want to return a file if the function call is requesting the folder that file directly resides within. Consider the following example wherein the file system contains one sub-directory and two files; \texttt{/test.txt}, \texttt{/folder/other.txt}. If \texttt{readdir} requests a path of \texttt{/folder/}, only \texttt{/folder/other.txt} should be returned. This can be accomplished by testing if the requested path is a prefix of the file name. However, this method fails when directories are created within directories - files within sub-directories of the path should not be returned. This is fixed by checking the number of slashes in the file name and comparing this number of slashes in the path. Algorithm \ref{dirs} describes the \texttt{readdir} implementation.

\begin{algorithm}
\caption{Algorithm for the \texttt{readdir} implementation.}
\label{dirs}
\begin{algorithmic}[1]
\State add(`..')
\State add(`.')
\State pathSlashes $\gets$ number of slashes in path
\For{for file in (fileSizes and dirs)}
	\State fileSlashes $\gets$ number of slashes in file
	\If{path == /}
		\If{file contains one slash}
			\State add(file)
		\EndIf
	\ElsIf{path is a prefix of file and pathSlashes == fileSlashes - 1}
		\State add(file)
	\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

Changes will now need to be made to write the directories to the video file and to read them back, preserving the directory structure between unmounts and remounts. I chose to represent a directory as a file in the header of the video which has a value of $-1$ in the \texttt{number of triples} field. This meant the structure of the \texttt{FAF} did not need to be modified. The \texttt{readHeader} and \texttt{writeHeader} functions were modified appropriately.

These changes successfully implement the extension task and greatly improve the usability of the file system. With the exception of permissions and access and modification times, \texttt{Stegasis} now provides all the functionality one would expect from a typical file system.

%unlink doesnt work check for dirs...
%also have i implemented mv??

\subsubsection{Plausible deniability}

Similar to \texttt{TrueCrypt}'s hidden volume feature, I planned to implement plausible deniability by embedding two separate file systems within one video, each using a different user provided passphrase. The \textit{outer} volume will reside at the beginning of the video (where it usually would) and the user should populate this volume with files they are willing to reveal if necessary. The \textit{inner} volume will reside half way through the video file and the user should place sensitive files here. When forced to give up the encryption keys, the user can reveal the passphrase for the outer volume in confidence the inner volume will not be compromised.

This method is vulnerable to steganalysis attacks that would be able to detect the presence of the hidden volume half way through the video. To combat this, random data is embedded throughout the entire video during the format process using both passphrases. Since the volumes are encrypted, it will not be possible to tell if the identified embedded data is a hidden volume or just the random data written during the formatting process\textsuperscript{\cite{random}}.

The modifications required for \texttt{Stegasis} to implement this feature were surprisingly simple. A second passphrase command line flag \texttt{pass2} was added, if this is specified during the format process two headers are written at the start and in the middle of the video. The mount process now attempts to extract and decrypt the first header using the provided passphrase. If this fails, it then attempts to decode the second header (embedded within the middle frame). Depending on which header extracts successfully, the outer or hidden file system is presented to the user. Listing \ref{deny} shows an example use case of the plausible deniability functionality.

\begin{lstlisting}[language=bash,caption={\texttt{Stegasis} plausible deniability functionality.}, frame=single, label=deny]
$ stegasis format -alg=lsb -crypt=serpent -pass=outer -pass2=hidden -cap=20 video.avi
[...]
Format successful!
$ stegasis mount -alg=lsbp -crypt=serpent -pass=outer video.avi /tmp/steg
[...]
Mounting...

[Second Terminal]
$ echo 'outer' > /tmp/steg/outer.txt

[First Terminal]
<Control-C>
[...]
$ stegasis mount -alg=lsbp -crypt=serpent -pass=hidden video.avi /tmp/steg
[...]
Mounting...

[Second Terminal]
$ echo 'inner' > /tmp/steg/sensitivefile.txt
\end{lstlisting}

Since the header and data for the hidden file system is stored within the middle video frame onwards, it is possible to damage it by writing too much data to the outer volume. The user has effectively sacrificed half of the total embedding capacity in return for plausible deniability.

\subsubsection{Hiding data within audio}

It is stated within the project proposal that ``a substantial part of an \texttt{AVI} file may be the audio data''. I was correct to use the word ``may'' within this statement since it turns out that a very small percentage of an uncompressed \texttt{AVI} file is the audio data. Similarly low percentages apply to other video formats due to modern audio compression algorithms such as \texttt{MP3}. The question of how this extra embedding capacity could actually be utilised is also quite prevalent since \texttt{Stegasis} and the file system logic all rely on the idea of the video being broken up into frames. This concept does not translate easily over to audio. I therefore decided not to pursue this extension task. 

\subsubsection{Evaluation of embedding impact on video quality}

To evaluate the requirement ``Embedding should occur with no perceivable impact on video quality.'', a web application was required to be developed and hosted. Figure \ref{site} shows a screenshot of the finished website hosted at \texttt{www.stegasis.co.uk} for the majority of the duration of the project.

\begin{figure}[!h]
\centerline{\includegraphics[width=\textwidth]{images/site.png}}
\caption{Screen shot of the evaluation study site.}
\label{site}
\end{figure}

The user is presented with two images and asked the question ``Which image do you think contains hidden data?''. The user may inspect the image for as long as they wish, and by clicking on an image, they then select their choice.

In total there are 14,912 pairs of images, one of which is randomly selected for each page load. One of the images is the original video frame while the other has 2.5 kB of data embedded within it using the permuted \texttt{JPEG} embedding algorithm and a capacity setting of 20\% (the default value). The position of the ``correct'' image is randomly chosen and the file names of the images are also random strings. This tries to thwart any attempts at foul play, possibly damaging the collected results. When a user first visits the site, a cookie containing a unique ID is issued allowing data points from the same user to be aggregated together.\\

\noindent
The results of this evaluation study obtained by the implemented web application are discussed in Section \ref{security} and conclude that it is not possible to visually differentiate between the cover and stego objects at the default capacity setting of 20\%.

\subsection{Testing}
\label{testing}

\texttt{Stegasis} was tested using a combination of unit, integration and visual testing. Due to the decoupled nature of the steganogrphic embedding algorithms, it was easy to produce unit tests for the embedding and extraction functionality. A total of *largenumber* test cases were written testing all stenographic algorithms and associated code. Listing \ref{unittest} gives an example unit test.

\begin{lstlisting}[caption={Embedding algorithm unit test (\texttt{steg/steg\_algorithm\_test.cc:100}).}, frame=single, label=unittest]
bool SteganographicUnitTests::completeness(SteganographicAlgorithm alg) {
   char *in, *out; this->initRandomData(in, out);
   alg->embed(this->dummyChunk, in, this->dataSize, 0); 
   alg->extract(this->dummyChunk, out, this->dataSize, 0);
   return compareData(in, out);
};
\end{lstlisting}

The above unit test verifies the steganogrphic correctness of the stego systems, checking that data embedded using a key \textbf{k} is correctly extracted when using the same key.

I deemed it more appropriate to test the file system functionality via an integration test suite due to its highly coupled nature. The test suite revolved around a number of compressed archives containing test files and directory structures. \texttt{Stegasis} is first instructed to mount a test video into \texttt{/tmp/test}. These archives are then copied into the file system and uncompressed. Once the extraction process has completed, the resulting file system is traversed to check the contents is as expected.

Visual testing was also employed. For example, large media content such as high definition video was copied into the mounted volume and checked to see if it played back correctly. This is a good test case since the file (due to its size) will be spread across a large proportion of the video. Indeed, several bugs were identified using this testing approach.

The \texttt{AVI} parser was tested using a black box testing approach on a number of different uncompressed \texttt{AVI} videos. The parser prints out debug information about the video file which can be visually inspected. For example, the resolution of the video contained within the \texttt{BITMAPINFOHEADER} can be compared against the known value. Checking that the \texttt{AVI} still plays back after steganographic modification is also a good indication that the parser is operating successfully.

See the Appendix Section \ref{app:codetest} for some more testing code samples.


\vfill
\pagebreak

\section{Evaluation}
\subsection{Satisfaction of Requirements}

\texttt{Stegasis} satisfies all of the core requirements and addresses all of the proposed extension tasks. I therefore consider the project a success. Each requirement will now be addressed in turn.

\subsubsection{Embedding data within video files}

\texttt{Stegasis} does indeed allow data to be embedded within video files. Furthermore, it provides a total of 6 different steganogrphic embedding algorithms all of which satisfy correctness\footnote{Verified by unit test cases as explained in Section \ref{testing}.} and, an evaluation study discussed in Section \ref{security} below concludes that \texttt{Stegasis} can operate with no perceivable impact on video quality. A number of steganalysis tools were developed to test the security of the proposed steganographic systems, prompting the design and implementation of more secure embedding algorithms. Encryption functionality is also provided making use of the user provided passphrase. Finally, a capacity setting was also implemented allowing users to choose a trade off between steganographic security and embedding capacity.

\subsubsection{Providing a file system interface}

\texttt{Stegasis} allows users to specify a mount point at which the volume will be mounted and data written to and read from this volume will embedded and extracted from the video on the fly. Standard Unix tools including \texttt{cp}, \texttt{mv} and \texttt{rm} work as expected and the file system is correctly persevered between unmounts and remounts of the same video.

\subsubsection{Supporting uncompressed AVI}

Raw uncompressed \texttt{AVI} files are supported via a developed native parser which allows access to and modification of individual pixel data along with extraction of meta-data about the video.

\subsubsection{File system performance}

The performance of the file system allows full HD video content to be played back from directly within the volume (12 Mb/s). However, achieving read and write speeds in excess of 20 MB/s was not a trivial task. The file system can provide read and write speeds in excess of 30 MB/s (and under ideal conditions\footnote{These conditions are discussed in Section \ref{perf}.},  80MB/s.), but only for the \texttt{AVI} algorithms which do not encrypt the embedded data and only if the performance flag has been specified (to stop synchronous flushes to disk). Performance is discussed in more detail in Section \ref{perf}.

\noindent
The extension task requirements are now discussed individually. 

\subsubsection{Supporting multiple video formats}

The novel method described in Section \ref{extffmpeg} using \texttt{FFmpeg} allows \texttt{Stegasis} to seamlessly operate across virtually every video format available today. The basic implemented embedding algorithms operating on \texttt{JPEG} images (\texttt{DCT}, \texttt{DCTP}) offer large embedding capacities allowing multiple large files to hidden inside of a single video, while the more advanced implemented algorithms (\texttt{F4}, \texttt{F5}) offer high steganographic security.

\subsubsection{File system directory operations}

Directory functionality was successfully implemented allowing the creation and manipulation of directory structures, enabling users to organise their embedded files within folders. The \texttt{mv} and \texttt{rm} commands work as expected when operating on directories as well as normal files. 

\subsubsection{Embedding within audio}

This extension task was investigated but I decided not to pursue it due to the relativity little embedding capacity gain compared to the work required to implement it.

\subsubsection{Plausible deniability}
% write random data using both passwords i.e. do it twice 
Plausible deniability functionality was implemented allowing a second hidden file system to be optionally embedded within a video. Depending on the passphrase provided by the user during mounting, either the outer or inner volume is presented. This satisfies the first requirement point. The second point, that the hidden volume should not be detectable, has also been satisfied since it is not possible to differentiate between the random data written during the format process and the second encrypted hidden volume\textsuperscript{\cite{random}}.

\subsubsection{Evaluation of the visual impact of embedding}

A web application was implemented and hosted for the majority of the duration of the project. A total of 2040 data points were collected from 21 unique users. The results are discussed below in Section \ref{security}, and the outcome of the study confirmed that it was not possible for the users to visually differentiate videos produced by \texttt{Stegasis} when using the default capacity setting (20\%). This satisfies the final extension task.\\

\noindent
\texttt{Stegasis} therefore has addressed all of the proposed extension tasks, further cementing the success of the project.

\subsection{Security}
\label{security}

Although security of the steganographic algorithms was not a major focus of this project, steganalysis techniques were implemented and these led to more secure algorithms being developed. The evaluation user study was also focused on security - attempting to decide if it is possible to visually differentiate between cover and stego objects produced by \texttt{Stegasis} when using its default capacity setting. The results of this study are now statistically analysed.

Due to the layout of the website, if a user cannot tell the difference between the two presented images, they will select one arbitrarily. From the phrasing of the question posed to the user, a response is considered correct if the image selected did contain hidden data and incorrect if it did not. If a user were to randomly guess each time, the resulting data stream would be a random stream of corrects and incorrects. Letting correct be represented by 1 and incorrect by 0, this stream of random corrects and incorrects becomes a random bit string. Therefore, if it can be shown that the collected data is a random bit string, it can then be concluded that the users must have been randomly guessing and therefore could not differentiate between the two presented images.

The raw bit string obtained from the user study is included in the Appendix Section \ref{app:userstudy}. To determine if the obtained bit string is in fact random, firstly a hypothesis test is constructed to test if the bits are i.i.d. Bernoulli(1/2) which would be the case for a truly random bit string.

Let the bit string $\mathbf{X} = X_1 \ldots X_n$, with each $X_i \stackrel{iid}{\sim} \text{Bernoulli}(p)$ define $T = \sum_{i=1}^{n}X_i$. $T$ is a sufficient statistic for $p$. Clearly $T \sim \text{Binomial}(n, p)$.

Test $H_{0}: p = \frac{1}{2}$ against $H_{1}: p \neq \frac{1}{2}$ at significance level $\alpha$. Under $H_0$, $T \sim \text{Binomial}(n, \frac{1}{2})$, by the de Moivre-Laplace theorem $T \sim N(\frac{n}{2}, \frac{n}{4})$ for large n. So $(1 - \alpha)$ confidence interval for $T$ is
\begin{equation*}
	\left[\text{ }\frac{n}{2} - z_{\alpha / 2}\sqrt{\frac{n}{4}},\text{ }\frac{n}{2} + z_{\alpha / 2}\sqrt{\frac{n}{4}}\text{ }\right].
\end{equation*}

For the bit string observed from the user study, $n = 2040 \text{ and } T = 1042$. At $\alpha = 5\%,\text{ } z_{\alpha / 2} = 1.9600$, the confidence interval is $[975, 1065]$ which contains $T$. Therefore there is insufficient evidence to reject the null hypothesis and therefore insufficient evidence to conclude the bit string is not random.

Secondly, a number of statistical randomness tests are used. Both \texttt{ent}\textsuperscript{\cite{ent}}, a pseudorandom number sequence test program is used. Listing \ref{entout} shows the output of \texttt{ent} when applied to the bit string.

\begin{lstlisting}[language={},caption={Output of \texttt{ent}.},frame=single, upquote=true,label=entout,showstringspaces=false]
Entropy = 0.999664 bits per bit.

Optimum compression would reduce the size
of this 2040 bit file by 0 percent.

Chi square distribution for 2040 samples is 0.95, and randomly
would exceed this value 33.00 percent of the times.

Arithmetic mean value of data bits is 0.5108 (0.5 = random).
Monte Carlo value for Pi is 3.523809524 (error 12.17 percent).
Serial correlation coefficient is -0.035776 (totally uncorrelated = 0.0).
\end{lstlisting}

These results strongly indicate that the bit string is random. 

These analyses show that the bit string with high probability is random and therefore that the users could not differentiate between the cover and stego objects produced by \texttt{Stegasis}.

Although we have concluded that \texttt{Stegasis} can operate with no perceivable visual impact on video quality, this does not imply that it will resist further steganalysis techniques. For example, the \textit{Histogram attack} which operates on \texttt{JPEG} images breaks the basic embedding algorithms (\texttt{DCT} and \texttt{DCTP}) implemented in the multiple video formats extension task (even using low capacity settings). The histogram attack enumerates the frequencies of the DCT coefficients of a given image. A characteristic of unmodified \texttt{JPEG} images is that its histogram is symmetrical about 0, that is, coefficients $n$ and $-n$ have roughly equal frequencies. This characteristic is lost when embedding occurs. Figure \ref{hist} shows the effectiveness of the attack, comparing the histogram of an original video frame to one with embedded data. It clearly manages to differentiate between the cover and stego objects.

\begin{figure}[!tbh]
\centerline{\includegraphics[width=\textwidth]{images/hist.png}}
\caption{The histogram attack on the \texttt{DCTP} algorithm.}
\label{hist}
\end{figure}

\texttt{F4} and \texttt{F5} however resist this attack and provide a much higher level of steganographic security. Jessica Fridrich et al. showed they were able to break the \texttt{F5} algorithm by estimating the cover image histogram by slightly cropping the stego image. However, \texttt{Stegasis} is able to spread the embedded data across thousands of \texttt{JPEG} images using a small capacity setting, so I am unsure how effective this attack would be.

The framework \texttt{Stegasis} provides makes is easy to implement more secure embedding algorithms which would be a possible future project direction.

\subsection{Performance}
\label{perf}

The performance of \texttt{Stegasis}, and in particular the file system, is very important to consider. As with \texttt{TrueCrypt}, using \texttt{Stegasis} should constitute a similar experience to copying files onto removable storage. 

\subsubsection{Performance of the file system}

Due to the large embedding capacities offered, large files are expected to be copied into the file system and therefore embedded into the video. The write performance of the file system was therefore given a lot of attention during the implementation. The biggest improvement in file system performance was obtained by enabling the \texttt{FUSE} \texttt{big\_writes} mount option. By default, \texttt{FUSE} limits write calls to blocks of 4096 bytes, \texttt{big\_writes} allows this limit to be increased to 65 kB. Figure \ref{writeper} shows the effect of varying the block size on write performance for the LSB embedding algorithm.

\pgfplotsset{scaled x ticks=false}
\begin{figure}[!tbh]
\centering
    \begin{tikzpicture}
    \begin{axis}[title={Write performance of the file system varying block size},%
    xlabel={Block size (bytes)}, ylabel={Write speed (MB/s)},%
    legend cell align=left, width=0.95\textwidth,legend style={at={(0.95,0.8)},anchor=north east}]

        \addplot[red,thick,error bars/.cd,y dir=both,y explicit]
            table[x index=0, y index=1, y error index=2]{data/write_per.txt};
        \addplot[blue,thick,error bars/.cd,y dir=both,y explicit]
            table[x index=0, y index=1, y error index=2]{data/write_nor.txt};

        \legend{With \texttt{-p} flag,Without \texttt{-p} flag}
    \end{axis}
    \end{tikzpicture}
    \caption[]{Write performance of the file system.}
\label{writeper}
\end{figure}

The data points for the graph were obtained using the command line tool \texttt{dd} as shown in Listing \ref{dd}. Note that this test provides ideal conditions, having a large block size and writing all zeros - most use cases will not be like this.

\begin{lstlisting}[caption={Testing the file system performance using \texttt{dd}.}, frame=single, label=dd,float, floatplacement=!htb]
$ dd if=/dev/zero of=test bs=65k count=1221
610+0 records in
610+0 records out
79953920 bytes (80 MB) copied, 0.456444 s, 77.1 MB/s
\end{lstlisting}

To evaluate the file system performance under more standard conditions, I timed the copying of an 80 MB video file into and out of the file system for the LSB algorithm using the \texttt{time} tool. This process was repeated multiple time and an average taken giving an average write speed of 33.6 MB/s and read speed of 46.3 MB/s. This is slower than above, but is still on par with USB 3.0 device speeds\textsuperscript{\cite{usb3}}, surpassing the performance requirement. As expected, the embedding algorithms which permute and encrypt data give worse file system performance as shown in Table \ref{algperf}, but I think this is a fair trade off.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|lll}
\cline{1-4}
\textbf{Stego System} & \textbf{Encryption Algorithm} & \textbf{File Size (MB)} & \textbf{Copy time (s)}      \\ \cline{1-4}
\texttt{LSB} & \texttt{AES} & 6.146 & 123   \\ \cline{1-4}
\texttt{LSB} & \texttt{TwoFish} & 6.146 & 123   \\ \cline{1-4}
\texttt{LSB} & \texttt{Serpent} & 6.146 & 123   \\ \cline{1-4}
\texttt{LSB} & \texttt{AES(Serpent(TwoFish))} & 6.146 & 123   \\ \cline{1-4}
\texttt{LSBP} & \texttt{AES} & 6.146 & 123   \\ \cline{1-4}
\texttt{LSBP} & \texttt{TwoFish} & 6.146 & 123   \\ \cline{1-4}
\texttt{LSBP} & \texttt{Serpent} & 6.146 & 123   \\ \cline{1-4}
\texttt{LSBP} & \texttt{AES(Serpent(TwoFish))} & 6.146 & 123   \\ \cline{1-4}
\texttt{DCT} & \texttt{AES} & 6.146 & 123   \\ \cline{1-4}
\texttt{DCT} & \texttt{TwoFish} & 6.146 & 123   \\ \cline{1-4}
\texttt{DCT} & \texttt{Serpent} & 6.146 & 123   \\ \cline{1-4}
\texttt{DCT} & \texttt{AES(Serpent(TwoFish))} & 6.146 & 123   \\ \cline{1-4}
\texttt{DCTP} & \texttt{AES} & 6.146 & 123   \\ \cline{1-4}
\texttt{DCTP} & \texttt{TwoFish} & 6.146 & 123   \\ \cline{1-4}
\texttt{DCTP} & \texttt{Serpent} & 6.146 & 123   \\ \cline{1-4}
\texttt{DCTP} & \texttt{AES(Serpent(TwoFish))} & 6.146 & 123   \\ \cline{1-4}
\texttt{F4} & \texttt{AES} & 6.146 & 123   \\ \cline{1-4}
\texttt{F4} & \texttt{TwoFish} & 6.146 & 123   \\ \cline{1-4}
\texttt{F4} & \texttt{Serpent} & 6.146 & 123   \\ \cline{1-4}
\texttt{F4} & \texttt{AES(Serpent(TwoFish))} & 6.146 & 123   \\ \cline{1-4}
\texttt{F5} & \texttt{AES} & 6.146 & 123   \\ \cline{1-4}
\texttt{F5} & \texttt{TwoFish} & 6.146 & 123   \\ \cline{1-4}
\texttt{F5} & \texttt{Serpent} & 6.146 & 123   \\ \cline{1-4}
\texttt{F5} & \texttt{AES(Serpent(TwoFish))} & 6.146 & 123   \\ \cline{1-4}
\end{tabular}
\caption{Steganographic and cryptographic algorithm combination performance.}
\label{algperf}
\end{table}


\subsubsection{Performance of video formatting}

Another area worth considering is the time \texttt{Stegasis} takes to format video files. Although it is hard to quantify a ``good'' format time, I would expect a time of under 1 minute to be reasonable for an average 5 minute video. The format time of \texttt{AVI} files is more dependent on disk read performance, whereas for other video formats, processor performance will be more important (due to the video transcoding involved). I measured the time taken to format a variety of video files on my desktop computer. The results are summarised in table \ref{formatres} below.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|lll}
\cline{1-3}
\textbf{Video file} & \textbf{Volume capacity (MB)} & \textbf{Format Time (seconds)}      \\ \cline{1-3}
700 MB 10 second \texttt{AVI} & 96.60 & 6.146   \\ \cline{1-3}
14 MB 3 minute \texttt{MP4} & 28.98 & 13.143   \\ \cline{1-3}
34 MB 4 minute \texttt{MP4} & 159.07 & 29.270   \\ \cline{1-3}
80 MB 18 minute \texttt{FLV} & 55.63 & 45.810  \\ \cline{1-3}
\end{tabular}
\caption{Video format times}
\label{formatres}
\end{table}

\vfill
\pagebreak

\section{Conclusions}

Informally, I wanted this project to result in the ``\texttt{TrueCrypt} of video steganography'' focusing on a practical application allowing multiple files to be easily steganographically embedded within video files utilising a file system interface. This involved researching multiple technical fields (mainly Steganography, file systems and video formats) and developing an application to combine them all into a polished tool.

A number of steganographic embedding algorithms were researched and implemented borrowing ideas and algorithms from cryptography to further increase security. A file system in user space residing within a video file was designed and implemented offering the majority of the functionality one would expect from a standard file system. A native \texttt{AVI} parser was developed along with a novel method of supporting other video formats utilising \texttt{FFmpeg}. Finally a Linux command-line application, \texttt{Stegasis}, was produced combining the above into a single application.

\texttt{Stegasis} satisfies all of the core project requirements and implements all of the proposed extension tasks. In reference to the evaluation section of this document, I very much consider this project a success and hope to release \texttt{Stegasis} in the near future.

\subsection{Lessons Learnt}

The ``Launch early, iterate often'' approach taken to development did come with some drawbacks. Most notably, design decisions made early on during development were sometimes not given as much thought as they possibly should have. This resulted in some issues arising much later during development which required a lot of work to correct. Had due thought been given to these decision at the start of the development process, a large amount of time spent refactoring code could have been saved. 

\subsection{Future Project Directions}

As discussed in the evaluation section, \texttt{Stegasis} currently lacks secure steganographic embedding algorithms. Further work would therefore likely involve implementing more secure embedding algorithms. Another avenue to explore would be implementing more native video decoders. For example, a native \texttt{MP4} decoder could be produced which embedded data within motion vectors. This has an advantage over the \texttt{FFmpeg} method since a new, \texttt{MKV} video is not produced - the \texttt{MP4} would be modified in place as occurs with \texttt{AVI} files.
Finally, it would be great for \texttt{Stegasis} to be cross platform. Developing a Linux only application severely limits the target audience. However, since the file system was implemented using \texttt{FUSE} (which is not compatible with Windows) this may prove tricky.

\vfill

\pagebreak

\begin{thebibliography}{1}

\bibitem{digmedia} \emph{Steganography in Digital Media}, Jessica Fridrich 2010

\bibitem{uklaw} \emph{Regulation of Investigatory Powers Act 2000}\\ 
\path{www.legislation.gov.uk/ukpga/2000/23/section/53}

\bibitem{survey} \emph{A Survey of Steganographic and Steganalytic Tools for the Digital Forensic Investigator}, Pedram Hayati et al.\\
\path{www.pedramhayati.com/images/docs/survey_of_steganography_and_steganalytic_tools.pdf}

\bibitem{truecrypt} \emph{TrueCrypt is a source-available freeware utility used for on-the-fly encryption.}\\
\path{www.truecrypt.org}

\bibitem{nsa} \emph{The NSA Thinks You Are an Extremist If You Care About Privacy}, Fahmida Rashid 2014, PCMag\\
\path{securitywatch.pcmag.com/privacy/325273-the-nsa}

\bibitem{prisoner} \emph{The prisoners' problem and the subliminal channel}, Gustavus Simmons 1984, Advances in Cryptology, pp. 51 - 67

\bibitem{kirc} \emph{La Cryptographie Militaire}, Auguste Kerckhoffs 1883

\bibitem{steganalysis} \emph{Steganalysis: The Investigation of Hidden Information}, Neil Johnson and Sushil Jajodia 1998 

\bibitem{avicommon} \emph{Using Video Data}, ATLAS.ti 6 2011\\
\path{atlasti.com/wp-content/uploads/2014/05/video_formats.pdf}

\bibitem{aviformat} \emph{AVI RIFF File Reference}, Microsoft\\
\path{msdn.microsoft.com/en-us/library/windows/desktop/dd318189\%28v=vs.85\%29.aspx}

\bibitem{jpegsteg} \emph{Steganography and Steganalysis of JPEG Images}, Mahendra Kumar\\
\path{www.cise.ufl.edu/~makumar/proposalppt.pdf}

\bibitem{jsteg} \emph{JSteg: Steganography and Steganalysis}, Murali P 2009\\
\path{csis.bits-pilani.ac.in/faculty/murali/netsec-09/seminar/refs/anuroopsrep.pdf}

\bibitem{outguess} \emph{Hide and Seek: An Introduction to Steganography}, Niels Provos and Peter Honeyman 2003, p. 36\\
\path{niels.xtdnet.nl/papers/practical.pdf}

\bibitem{f5} \emph{F5  A Steganographic Algorithm}, Andreas Westfeld\\
\path{www2.htw-dresden.de/~westfeld/publikationen/f5.pdf}

\bibitem{libjpeg} \emph{Libjpeg, a widely used C library for reading and writing JPEG image files}\\
\path{libjpeg.sourceforge.net}

\bibitem{sensitive} \emph{Human eye sensitivity and photometric quantities}\\
\path{www.ecse.rpi.edu/~schubert/Light-Emitting-Diodes-dot-org/Sample-Chapter.pdf}

\bibitem{ffmpeg} \emph{FFmpeg: A complete, cross-platform solution to record, convert and stream audio and video}\\
\path{www.ffmpeg.org}

\bibitem{ffmpegcodec} \emph{FFmpeg Codecs Documentation}\\
\path{www.ffmpeg.org/ffmpeg-codecs.html}

\bibitem{fuse} \emph{FUSE: File system in userspace}\\
\path{fuse.sourceforge.net}

\bibitem{fuseper} \emph{Linus vs FUSE: Kernel file system vs FUSE}, Sage 2011\\
\path{ceph.com/dev-notes/linus-vs-fuse}

\bibitem{stegostick} \emph{Stegostick: A steganographic Tool that lets you hide any file into any file}, 2008\\
\path{sourceforge.net/projects/stegostick}

\bibitem{stegomagic} \emph{Stegomagic: An encrypting software application designed specifically for helping you hide files or messages in media items}, 2014\\
\path{www.softpedia.com/get/Security/Encrypting/StegoMagic.shtml}

\bibitem{tcsteg} \emph{Real steganography with TrueCrypt}, Martin Fiedler 2011\\
\path{keyj.emphy.de/real-steganography-with-truecrypt}

\bibitem{stegovideo} \emph{Stegovideo: A unique tool for hiding information in video}, Oleg Petrov 2011\\
\path{www.compression.ru/video/stego_video/index_en.html}

\bibitem{openpuff} \emph{OpenPuff: A steganography tool supporting many carrier formats}, EmbeddedSW\\
\path{embeddedsw.net/OpenPuff_Steganography_Home.html}

\bibitem{steganosaurus} \emph{Steganosaurus is a dissertation project exploring the application of video steganographic and video steganalysis techniques.}, James Ridgway 2014\\
\path{www.steganosaur.us}

\bibitem{bitrate} \emph{YouTube Advanced encoding settings.}, Google 2014\\
\path{support.google.com/youtube/answer/1722171?hl=en-GB}

\bibitem{usb2} \emph{Example USB 2.0 flash drive}, Ebuyer 2015\\
\path{www.ebuyer.com/543103-toshiba-transmemory-8gb}

\bibitem{javafuse} \emph{JavaFUSE provides Java bindings for FUSE}, Aditya Rajgarhia 2010\\
\path{code.google.com/p/javafuse/}

\bibitem{turbojpeg} \emph{TurboJPEG: A Java interface for libjpeg-turbo}\\
\path{www.libjpeg-turbo.org}

\bibitem{javaper1} \emph{Numeric performance in C, C\# and Java}, Peter Sestoft 2010\\
\path{www.itu.dk/people/sestoft/papers/numericperformance.pdf}
 
\bibitem{javaper2} \emph{Time Comparing between Java and C++ Software}, Asad Mahmoud Alnaser et al. 2012\\
\path{www.scirp.org/journal/PaperDownload.aspx?paperID=21960}
 
\bibitem{javaper3} \emph{A Java vs. C++ performance evaluation: a 3D modeling benchmark}, L. Gherardi et al.\\
\path{www.best-of-robotics.org/pages/publications/gherardi12java.pdf}

\bibitem{iterate} \emph{Release Early, Release Often}, Eric S. Raymond \\
\path{www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/ar01s04.html}

\bibitem{inver} \emph{The Dependency Inversion Principle}\\
\path{www.objectmentor.com/resources/articles/dip.pdf}

\bibitem{chi} \emph{Attacks on Steganographic Systems: Breaking the Steganographic Utilities EzStego, Jsteg, Steganos, and S-Tools and Some Lessons Learned}, Andreas Westfeld and Andreas Pfitzmann 2000

\bibitem{lcg} \emph{The Linear Congruential Method}, Donald Knuth, The Art of Computer Programming, Volume 2, p. 9

\bibitem{hull} \emph{Random number generators}, T E. Hull A. R. Dobell 1962, SIAM Review, Volume 4, Issue 3

\bibitem{keyd} \emph{PKCS \#5: Password-Based Cryptography Standard}, RSA Laboratories.

\bibitem{pool} \emph{The Whirlpool Secure Hash Function}, Williams Stallings 2006\\
\path{www.seas.gwu.edu/~poorvi/Classes/CS381_2007/Whirlpool.pdf}

\bibitem{random} \emph{Random versus Encrypted Data}, A. G. Basile 2008\\
\path{opensource.dyc.edu/sites/default/files/random-vs-encrypted.pdf}

\bibitem{ent} \emph{Ent: A Pseudorandom Number Sequence Test Program}, John Walker 2008\\
\path{www.fourmilab.ch/random}

\bibitem{usb3} \emph{Lexar 8GB USB 3.0 JumpDrive}, Ebuyer 2015\\
\path{www.ebuyer.com/399229-lexar-8gb-jumpdrive}

\vfill

\end{thebibliography}

\pagebreak

\appendix
\section{Details of the AVI file format}
\label{app:avi}

\subsection{Detailed AVI form}

Listing \ref{aviform} shows an expanded form of the \texttt{AVI} structure.

\begin{lstlisting}[language=C, caption={Detailed \texttt{AVI RIFF} form}, frame=single, upquote=true,label=aviform,showstringspaces=false]
RIFF (
  'AVI '
  LIST (
    'hdrl'
    'avih'(<Main AVI Header>)
    LIST (
      'strl'
      'strh'(<Stream header>)
      'strf'(<Stream format>)
      [ 'strd'(<Additional header data>) ]
      [ 'strn'(<Stream name>) ]
      ...
    )
    ...
  )
  LIST (
    'movi'
    {SubChunk | 
      LIST (
        'rec '
        SubChunk1
        SubChunk2
        ...
        )
      ...
    }
    ...
  )
  ['idx1' (<AVI Index>) ]
)
\end{lstlisting}

\vfill
\pagebreak

\subsection{The AVI and Bitmapinfo headers}

Listing \ref{aviheader} shows the definition of the main \texttt{AVI} header.

\begin{lstlisting}[caption={The \texttt{AVIMAINHEADER} structure.},frame=single, upquote=true,label=aviheader,showstringspaces=false]
typedef struct _avimainheader {
  char     fcc[4];
  int32_t  cb;
  int32_t  dwMicroSecPerFrame;
  int32_t  dwMaxBytesPerSec;
  int32_t  dwPaddingGranularity;
  int32_t  dwFlags;
  int32_t  dwTotalFrames;
  int32_t  dwInitialFrames;
  int32_t  dwStreams;
  int32_t  dwSuggestedBufferSize;
  int32_t  dwWidth;
  int32_t  dwHeight;
  int32_t  dwReserved[4];
} AVIMAINHEADER;
\end{lstlisting}

Listing \ref{bitmap} shows the definition of the \texttt{BITMAPINFOHEADER}.

\begin{lstlisting}[caption={The \texttt{BITMAPINFOHEADER} structure.},frame=single, upquote=true,label=bitmap,showstringspaces=false]
typedef struct tagBITMAPINFOHEADER {
  uint32_t  biSize;
  uint32_t  biWidth;
  uint32_t  biHeight;
  uint16_t  biPlanes;
  uint16_t  biBitCount;
  uint32_t  biCompression;
  uint32_t  biSizeImage;
  uint32_t  biXPelsPerMeter;
  uint32_t  biYPelsPerMeter;
  uint32_t  biClrUsed;
  uint32_t  biClrImportant;
} BITMAPINFOHEADER;
\end{lstlisting}

\vfill
\pagebreak

\section{Stegasis example use} 
\label{app:steg}

\subsection{Stegasis usage information}

Listing \ref{usage} shows the information displayed to the user when the program is run with no (or incorrect) arguments supplied.

\begin{lstlisting}[language={},caption={\texttt{Stegasis} usage information.},frame=single, upquote=true,label=usage,showstringspaces=false]
   _____ _                                  
  / ____| |                     (_)         
 | (___ | |_ ___  __ _  __ _ ___ _ ___      
  \___ \| __/ _ \/ _` |/ _` / __| / __|  
  ____) | ||  __/ (_| | (_| \__ \ \__ \ 
 |_____/ \__\___|\__, |\__,_|___/_|___/ 
                  __/ | v2.1a               
                 |___/                      

Stegasis usage:
  stegasis <command> [-p,-f] -alg=<alg> -pass=<pass> -cap=<capacity>       <video_path> <mount_point>
------------------------------------------------------------------------
Example useage:
  stegasis format -alg=lsbk -pass=password123 -cap=50 /media/video.avi
  stegasis mount -alg=lsbk -pass=password123 /media/video.avi /tmp/test
Commands:
  format  Formats a video for use with stegasis
  mount  Mounts a formatted video to a given mount point
Required Flags:
  -alg  Embedding algorithm to use, see below
  -cap  Percentage of frame to embed within in percent
Optional flags:
  -pass  Passphrase used for encrypting and permuting data
  -pass2 Passphrase used for encrypting and permuting the hidden volume
  -p  Do not flush writes to disk until unmount
  -f  Force the FFmpeg decoder to be used
Embedding Algorithms:
  Uncompressed AVI only:
    lsb:  Least Significant Bit Sequential Embedding
    lsbk:  LSB Sequential Embedding XORd with a psudo random stream
    lsbp:  LSB Permuted Embedding using a seeded LCG
    lsb2:  Combination of lsbk and lsbp
    lsba:  LSB Permuted Embedding encrypted using AES
    
  Other video formats:
    dctl:  LSB Sequential Embedding within DCT coefficients
    dctp:  LSB Permuted Embedding within DCT coefficients
    dct2:  Combination of dctp and lsbk
    dcta:  LSB Permuted Embedding encrypted with AES
    dct3:  LSB Permuted Embedding encrypted with AES->Twofish->Serpent
\end{lstlisting}

\subsection{Example use case}

Listing \ref{usecase} shows an example use of \texttt{Stegasis}, formatting and mounting a video with complete command line output.

\begin{lstlisting}[caption={\texttt{Stegasis} example use.},frame=single, upquote=true,label=usecase,showstringspaces=false]
$ stegasis format -alg=lsbp -pass=hunter2 -cap=20 /media/Backup/video.avi 
   _____ _                                  
  / ____| |                     (_)         
 | (___ | |_ ___  __ _  __ _ ___ _ ___      
  \___ \| __/ _ \/ _` |/ _` / __| / __|  
  ____) | ||  __/ (_| | (_| \__ \ \__ \ 
 |_____/ \__\___|\__, |\__,_|___/_|___/ 
                  __/ | v2.1a               
                 |___/                      
Filesize: 776143108
Totalframes: 280
Width: 1280
Height: 720

Reading AVI chunks...
100% [==================================================]
Finished parsing AVI file

Volume capacity: 19.32MB

Writing back to disc...
100% [==================================================]
Format successful!

$ stegasis mount -alg=lsbp -pass=hunter2 /media/Backup/video.avi /tmp/steg
   _____ _                                  
  / ____| |                     (_)         
 | (___ | |_ ___  __ _  __ _ ___ _ ___      
  \___ \| __/ _ \/ _` |/ _` / __| / __|  
  ____) | ||  __/ (_| | (_| \__ \ \__ \ 
 |_____/ \__\___|\__, |\__,_|___/_|___/ 
                  __/ | v2.1a               
                 |___/                      
Filesize: 776143108
Totalframes: 280
Width: 1280
Height: 720

Reading AVI chunks...
100% [==================================================]
Finished parsing AVI file

Header: STEG
Mounting...

[Second Terminal]
$ cd /tmp/steg
/tmp/steg$ cp ~/vid.mp4 .

[Stegasis Terminal]
Embeding, Frame: 203, Size: 36158, Offset: 0
Compacting header...
100% [==================================================]
Writing back to disc...
100% [==================================================]

[Second Terminal]
/tmp/steg$ ls -lah
total 4.0K
drwxr-xr-x  2 root root    0 Jan  1  1970 .
drwxrwxrwt 10 root root 4.0K Jan 15 21:59 ..
-rwxr-xr-x  1 root root  14M Jan  1  1970 lba2.mp4

[Stegasis Terminal]
<Control-C>
Unmounting...
Compacting header...
100% [==================================================]
Writing back to disc...
100% [==================================================]
Successfully unmounted
\end{lstlisting}

\vfill
\pagebreak

\section{Detailed Code samples} 
\label{app:code}

This section contains select detailed code samples.

\subsection{Chi-Squared attack}
\label{app:chi}

Listing \ref{chipy} shows an implementation of the Chi-Squared attack in Python which operates on the \texttt{PPM} image format.

\begin{lstlisting}[language=Python,caption={Chi-Squared attack Python implementation.}, frame=single,label=chipy,showstringspaces=false,upquote=true]
from scipy import integrate, special

file_bytes = open(sys.argv[1], 'rb').read()

header = file_bytes[:2]
if header != 'P6':
  print 'File is not a P6 ppm.'
  sys.exit(0)

fp = 3
width = ''
while True:
  b = file_bytes[fp]
  fp += 1
  if b == ' ':
      break
  width += b

height = ''
while True:
  b = file_bytes[fp]
  fp += 1
  if b == ' ':
      break
  height += b

max_pixel_val = ''
while True:
  b = file_bytes[fp]
  fp += 1
  if b == ' ':
      break
  max_pixel_val += b

output = [0]*100

# fp is now on the first pixel red byte
frameStart = fp
for h in range(1, 100):
  fp = frameStart
  totalPixels = math.floor((h/100.0)*int(width)*int(height))
  X = [0]*(128*3) # X[k] = frequency(2k)
  Y = [0]*(128*3) # Y[k] = frequeincy(2k+1)
  Z = [0.0]*(128*3)

  # Populate the frequency arrays
  end = fp + totalPixels*3
  while fp < end:
      b = ord(file_bytes[fp])
      if b % 2 == 0:
          X[b/2] += 1
      else:
          Y[(b-1)/2] += 1
      fp += 1

   # Calculate theoretically expected frequency
  for i in range(len(Z)):
      Z[i] = (X[i] + Y[i]) / 2.0

  n = 128
  for k in range(127):
      if X[k] + Y[k] <= 4:
          X[k] = 0
          Y[k] = 0
          n -= 1

  X2 = 0.0
  for i in range(128):
      if Z[i] == 0:
          continue
      X2 += ((X[i] - Z[i])**2) / Z[i]

  # Calculate probability of embedding
  p = 1.0 - special.gammainc((n-1)/2.0, X2/2.0)
  output[h] = p

# Print results to stdout
for i in range(1, len(output)):
  print str(i) + " " + str(output[i])
\end{lstlisting}
\vfill
\pagebreak

\subsection{Reading and writing to the file system}
\label{app:coderead}

Listing \ref{readfs} shows the final implemented version of the \texttt{FUSE} read function call implementation.

\begin{lstlisting}[caption={\texttt{FUSE} read function call implementation.}, frame=single, label=readfs,showstringspaces=false,upquote=true]
int SteganographicFileSystem::read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {
  unordered_map<string, int>::const_iterator file = this->fileSizes.find(path);
  
  if (file == this->fileSizes.end() || offset > file->second) 
    return -ENOENT;
  if (size + offset > file->second) 
    size = file->second - offset;
  
  vector<FileChunk> fileChunks = this->fileIndex[path];
  int bytesRead = 0, chunkNum = 0, bytesWritten = 0;
  
  for (struct FileChunk c : fileChunks) {
    if (bytesRead + c.bytes > offset) {
      break;
    } else {
      bytesRead += c.bytes;
      chunkNum ++;
    }
  }
  while (bytesWritten < size) {
    struct FileChunk chunk = fileChunks.at(chunkNum);
    int chunkOffset = offset - bytesRead;
    int bytesLeftInChunk = chunk.bytes - chunkOffset;
    bytesLeftInChunk = min((int)(size - bytesWritten), bytesLeftInChunk);

    printf("\e[1A"); 
    printf("\e[0K\rExtracting bytes: %d, offset: %d, frame: %d\n", bytesLeftInChunk, chunk.offset, chunk.frame);
    if (chunkOffset == 0) {
      this->extract((int *)&chunk.frame, (int *)&chunk.offset, bytesLeftInChunk, buf+bytesWritten);
    } else {
      char *temp = (char *)malloc(chunk.bytes * sizeof(char));
      this->extract((int *)&chunk.frame, (int *)&chunk.offset, chunk.bytes, temp);
      memcpy(buf + bytesWritten, temp + chunkOffset, bytesLeftInChunk);
      free(temp);
    }
    bytesWritten += bytesLeftInChunk;
    bytesRead = offset;
    chunkNum ++;
  }
  return size;
};
\end{lstlisting}

\noindent
Listing \ref{writefs} shows the final implemented version of the \texttt{FUSE} write function call implementation.

\begin{lstlisting}[caption={\texttt{FUSE} write function call implementation.}, frame=single, label=writefs,showstringspaces=false,upquote=true]
int SteganographicFileSystem::write(const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {
  int bytesWritten = 0, nextFrame = 0, nextOffset = 0; 

  this->decoder->getNextFrameOffset(&nextFrame, &nextOffset);  

  struct FileChunk triple;
  triple.frame = nextFrame;
  triple.offset = nextOffset;
  triple.bytes = 0;

  while (bytesWritten < size) {
    this->decoder->getNextFrameOffset(&nextFrame, &nextOffset);  

    printf("\e[1A"); 
    printf("\e[0K\rEmbeding, nextFrame: %d, nextOffset: %d, bytesWritten: %d\n", nextFrame, nextOffset, bytesWritten);
    int tmp = this->alg->embed(this->decoder->getFrame(nextFrame), (char *)(buf + bytesWritten), size-bytesWritten, nextOffset); 
    triple.bytes += tmp;
    bytesWritten += tmp;
  }
  this->fileIndex[path].push_back(triple);

  if (offset == 0) {
    this->fileSizes[path] = size;
  } else {
    this->fileSizes[path] += size;
  }
  this->mux.unlock();
  return size;
};
\end{lstlisting}

\subsection{Implementing F5}
\label{app:f5}

The \texttt{F5} steganographic algorithm, developed by Andreas Westfeld, embeds data within the LSBs of DCT coefficients within \texttt{JPEG}  images. \texttt{F5} implements matrix encoding to improve embedding efficiency and is not vulnerable to the Chi-Squared and Histogram attacks. The \texttt{F5} embedding procedure is summarised in Algorithm \ref{algf5}.

\begin{algorithm}[!h]
\caption{The \texttt{F5} algorithm.}
\label{algf5}
\begin{algorithmic}[1]
\State Estimate the embedding capacity of the carrier medium
\State Determine the parameter k from the message size and embedding capacity. 
\State Calculate the code word length $n = 2^k - 1$
\State Embed the secret message with $(1, n, k)$ matrix encoding:
\State \ \ \ Fill a buffer with the LSBs of $n$ nonzero DCT coefficients
\State \ \ \ Hash this buffer
\State \ \ \ \texttt{XOR} the next k bits of the message with the hash value
\State \ \ \ If the output $i$ is nonzero, the absolute value of the coefficient at buffer index $i-1$ is decremented
\State \ \ \ Test for shrinkage. If so, jump to line 5, else advance the coefficients behind the buffer
\State \ \ \ If there is still message data, jump to line 5, else return
\end{algorithmic}
\end{algorithm}

\texttt{F5} only embeds data within zero valued DCT coefficients. This can lead to a situation known as \textit{shrinkage} which occurs when a coefficient with absolute value 1 is decremented, becoming zero. The extraction processes cannot distinguish between zero valued coefficients skipped and those which were decremented. Therefore when shrinkage occurs, that k-bit message must be embedded again.
To estimate the embedding capacity of the carrier medium taking into account possible shrinkage the following formula is used:
\begin{center}
$\mathcal{C} = DCT - DCT/64 - DCT_{0} - DCT_{1} + 0.49 \cdot DCT_{1}$
\end{center}
where $DCT$ is the total number of DCT coefficients in the image, $DCT_{0}$ the total number of zero valued coefficients and $DCT_{1}$ the total number of coefficients with absolute value 1. $-0.51 \cdot DCT_{1}$ is the estimated loss due to shrinkage.

The embedding rate is defined as:
\begin{center}
$\mathcal{R}(k) = \dfrac{k}{2^k - 1}$
\end{center}
and is used to compute the optimal value for $k$. From the estimated capacity $\mathcal{C}$ and the message length $m$, the optimal embedding rate is calculated as $r = \dfrac{m}{\mathcal{C}}$ we then seek the maximum integer $k \geq 1$ such that:
\begin{center}
$\mathcal{R}(k) > r$
\end{center}
The hash function used to hash the LSBs of the nonzero DCT coefficients is the bitwise \texttt{XOR} of each element:
\begin{equation*}
  f(\mathbf{a}) = \sideset{}{a_{i} \cdot i}\bigoplus_{i=1}^{n}
\end{equation*}
The index of the coefficient to modify (if any) is calculated by \texttt{XOR}ing $k$ bits of the message with the hash of the coefficient buffer as follows:
\begin{equation*}
  i = M_{k} \oplus f(\text{buffer})
\end{equation*}
If $i \neq 0$ then the $(i - 1)$th buffer elements coefficients absolute value is decremented by 1.\\

\noindent 
Extraction follows a similar procedure in which blocks of $n$\footnote{There are some fiddly issues here which are not mentioned within the original paper on \texttt{F5} since the extraction procedure must know the value of $k$ in advance along with the number of embedded bits within the image. My solution for this was to embed the value of $k$ and the number of embedded bits within the second \texttt{JPEG} component using the basic \texttt{JSteg} algorithm. The \texttt{F5} extraction producer can then access this information.}  nonzero valued DCT coefficients are hashed to give $k$ message bits. These need to be collected together and return as a byte array.

Listing \ref{f5imp} shows a cut down version of the final implementation.


\begin{lstlisting}[caption={\texttt{F5} embedding implementation (\texttt{steg/f5.cc:86})).}, frame=single, label=f5imp,showstringspaces=false,upquote=true]
virtual int embed(Frame *c, char *data, int reqByteCount, int offset) {
  this->crypt->encrypt(data, reqByteCount);
  JBLOCKARRAY frame;
  int row, block, co;
  // Estimate the embedding capacity
  int totalCoefficients = this->dec->getFrameHeight() * this->dec->getFrameWidth() * 64;
  int zeroCoefficients = 0, oneCoefficients = 0;
  for (int i = 0; i < totalCoefficients; i ++) {
    this->getCoef(lcg.map[i], &row, &block, &co);
    frame = (JBLOCKARRAY)c->getFrameData(row, 1);
    if (frame[0][block][co] == 0) zeroCoefficients ++;
    if (frame[0][block][co] == 1 || frame[0][block][co] == -1) oneCoefficients ++;  
  }
  // In bits
  int embeddingCapacity = totalCoefficients - totalCoefficients/64 - zeroCoefficients - oneCoefficients - 0.49*oneCoefficients;
  // Force to be a multiple of 8
  embeddingCapacity -= embeddingCapacity % 8;
  if (embeddingCapacity < 8) {
    // Not point trying to embed anything in this frame
    int currentFrame, currentFrameOffset;
    this->crypt->decrypt(data, reqByteCount);
    return 0;
  }
  int bitsToEmbed = min(reqByteCount * 8, (int)(embeddingCapacity * (this->dec->getCapacity()/100.0)));
  double embeddingRate = (double)bitsToEmbed / (double)embeddingCapacity;
  char k = 1;
  while (true) {
    double rate = (double)k / (pow(2, k) - 1);
    if (rate < embeddingRate) break;
      k ++;
  }
  k --;
  int codeWordLength = pow(2, k) - 1;
  int bitsEmbedded = 0;  
  while (bitsEmbedded < bitsToEmbed) {
    int oldOffset = offset;
    int *coefficients = this->getNextCoefficientBlock(c, &offset, codeWordLength);
    if (coefficients == NULL) break;
    int hashOfCoefficients = this->hash(coefficients, codeWordLength);
    int dataBlock = this->getNextDataBlock(data, reqByteCount, k, bitsEmbedded);
    int index = hashOfCoefficients ^ dataBlock;
    if (index == 0) {
      // Don't need to do anything
      bitsEmbedded += k;
      continue;
    } else {
      // Need to decrement coefficent at index
      index --;
      if (this->decCo(c, oldOffset, codeWordLength, index) == 0) {
        // Shrinkage occured
        offset = oldOffset;
        continue;
      } else {
        bitsEmbedded += k;
        continue;
      }
    }  
    free(coefficients);
  }  
  
  return bitsEmbedded / 8;
}; 
\end{lstlisting}

\vfill
\pagebreak

\section{Testing}
\label{app:codetest}

\subsection{Unit Testing}

Unit tests...

\subsection{Integration Testing}

As briefly mentioned in the implementation section, the integration test suite makes use of a number of test archives. These archives are copied into the volume presented by \texttt{Stegasis} and extracted. The resulting file system is then traversed and the contents of files checked to make sure they match their original content. This process is automated using several bash scripts as shown in Listing \ref{inttest}.

\begin{lstlisting}[language=bash,caption={The simple integration test suite (\texttt{test/simple\_integration\_tests.sh}).},frame=single, upquote=true,label=inttest,showstringspaces=false]
#!/bin/bash

function cleanExit() {
  (kill $stegasis_pid)
  exit
}

# Run stegasis
(stegasis format --alg=lsba --pass=test $1)
(stegasis mount --alg=lsba --pass=test $1 /tmp/test) &
stegasis_pid=$!
# Wait for the video to mount
sleep 5

# Copy and extract the archives
cp *.tar /tmp/test
for f in *.tar; do tar xf $f -C /tmp/test; done
rm /tmp/test/*.tar

expected_files="dirfile2.txt  file1.txt  file2.txt  testdir"
files=$(ls -C /tmp/test)
if [ "$files" != "$expected_files" ]; then
  echo "ls returned incorrect file list"
  echo "$files"
  cleanExit
fi

expected_file_1="This is a test file."
expected_file_2="This is a different test file."
file1=$(cat /tmp/test/file1.txt)
file2=$(cat /tmp/test/file2.txt)
if [[ "$file1" != "$expected_file_1" || "$file2" != "$expected_file_2" ]]; then
  echo "Contents of file(s) incorrect"
  echo "$file1"
  echo "$file2"
  cleanExit
fi

expected_files_sub="dirfile1.txt"
files_sub=$(ls -C /tmp/test/testdir)
if [ "$files_sub" != "$expected_files_sub" ]; then
  echo "ls returned incorrect file list for sub directory"
  echo "$files_sub"
  cleanExit
fi

expected_file_1_sub="I am in a directory."
file1_sub=$(cat /tmp/test/testdir/dirfile1.txt)
if [[ "$file1_sub" != "$expected_file_1_sub" ]]; then
  echo "Contents of sub directory file(s) incorrect"
  echo "$file1_sub"
  cleanExit
fi


(kill $stegasis_pid)
sleep 3

echo -e "\nAll tests passed :)\n"
exit
\end{lstlisting}

Other similar tests exist which test different parts of the file system functionality. For example the moving of files using \texttt{mv} and copying large amounts of data using \texttt{cp}.

\vfill
\pagebreak

\section{User study results}
\label{app:userstudy}

Listing \ref{userdata} shows the the raw data collected from the user study.
\lstset{% Literate one-to-one mapping of numerals
    literate={0}{0}{1}%
             {1}{1}{1}%
}

\begin{lstlisting}[language=bash,caption={Data from the user study.},frame=single, upquote=true,label=userdata,breaklines=true]
Raw data: 010000011011110010011100000000000010110110000001001011101101011100110101101111011110000001011111001001110111001011100001011000111001110001000110010111001001001100000100010100111101011011101100010001100000011110110011010001110011101101111110001110011111101100011001111011101000011100011010001100111110111100110001010011110100010100011110000110111001110111101100101001111100111000010001110000111101000010010110010111011111011011101101100011101001100000000011011000111001100000010100111000000010000010101011110001011010101000100111010001101100111010000111100111101000100110011010010101101001010101111001010011100111001001001111000110101011100000001001000101100110100011010111011100110011010111111010111000111000110100010100010111010010000001110010010100010111101000001100100111011010101011110111010011011010010001011010111000010010110100100111101000111101010101101000011110010100101111100111110101101001000101001001001101001100101001010111010011001011010111110111011000000111100011000101101001001111101001000001110101000110010011110001111101110110110110101010100011001100010010011101010101100000010001111011010001101101010110110001000110111101100111111000011010111011011011101110001000110111011101101101010100111000101001000111001111000010001110101111001011000010010110011101000100100101110101101011100001111100110100100110011101100100000111000110011010011011011111110100111100001010110010111010000111100011001010110011010110011101110010101110100011011111100110001001000011010011101000101010101010100000001001010010011011000001110011001001100110111101100000101101011111001000111101110110110011010100100100100001100011110110010001100011010010111100011101000101010010111000101101111010001000111001011101110011101011110010001100111101010110110110110101011110110101010100110111001101110111111001010111101010111000110010101101000010101001111111010010011001110010000010111110001110100010011101110110111011111011100100011010000011010110000001100100011010010001101101101000001101010111111000101001001110000101111000001000101111001101110000001100001100
Total : 2040, Correct : 1042, Incorrect : 998
Users: 21
\end{lstlisting}

\vfill
\pagebreak

\section{Original Project Proposal} 

\begin{center}	
 	~\\[2.0cm]			
	\normalsize \textsc{Computer Science Part II Project Proposal}\\[2.0cm]     
    \HRule{0.5pt} \\                        
    \LARGE \textbf{\uppercase{Steganographic file systems within video files}}    
    \HRule{2pt} \\[30pt]        
    \normalsize Scott Williams, Christ's College\\[2pt]Originators: Scott Williams\\[25pt]           
    \normalsize \today            
     \vfill
\end{center}
\printauthor                
\newpage
\section*{Introduction and Description of the Work}

Steganography is the art of hiding messages within inconspicuous objects - a form of covert communication. Whereas cryptography protects only the content of a message, steganography attempts to conceal the fact that the message even exists. Steganography is particularly useful in countries where encryption is illegal or not suitable, e.g. within the UK, where encryption keys can be forced to be handed over.

There exist many freely available programs which offer message hiding functionality within digital media. However, the majority of these programs operate on single image files and therefore impose a hard limit on the size of message you can embed\footnote{JPEG images for example are typically only a few megabytes in size - limiting the size of files you can possibly embed.}. Many programs also constrain the type of message you can embed to be a simple text string. Video files on the other hand can be several gigabytes in size without arousing suspicion\footnote{Raw uncompressed \texttt{AVI} files are roughly 2GB per minute of footage.} providing an ideal container for multiple (possibly large) sensitive files. A file system interface would enable users to hide any number of files of any type - just by copying / creating files within the mounted volume. For these reasons, the proposed project focuses on steganographic file systems within video files.

I propose to develop an application which allows a file system to be embedded within a user provided video file. The application will also enable mounting and unmounting of video files with contained file systems. As part of the project I intend to explore a number of steganographic embedding algorithms all of which will be selectable within the final application.\\

\noindent
An example use of the final product (henceforward referred to as \texttt{Stegasis}):
\begin{verbatim}
  # Prepare an existing video file
  $ stegasis format -alg=lsb video.avi
     
  # Using stegasis mount we can directly mount the video file
  $ stegasis mount video.avi /mnt/volume
 
  # Create a file inside the file system
  $ echo "test" > /mnt/volume/test.txt
  # Unmount the file system
  $ stegasis umount /mnt/volume
\end{verbatim}
 
After doing some initial research on the topic of steganographic file systems, it seems a suitable approach will be to develop a FileSystem in Userspace using the FUSE package. A similar approach was taken within a paper in which a file system was embedded within multiple JPEG images. For the purposes of this project I'll be focusing on uncompressed raw \texttt{AVI} video files.
 
I propose a staged approach to the project where each stage implements an increasingly secure scheme of embedding the file system, for example starting with na\"{i}ve least significant bit embedding, showing how this can be broken using statistical analysis and then moving on to more advanced techniques (each method selectable via the --alg flag).
The main product of this project - \texttt{Stegasis} - as shown above will be a user facing application, enabling all versions of the algorithms described throughout the stages of the project to be run on user provided video files. A number of programs to analyse and break insecure schemes proposed early on during the project could also be produced.
This project would tie in nicely with the Part II courses Information Theory and Coding, Digital Signal Processing, and possibly Security II.

\section*{Resources Required}
I will be using the \texttt{C++} programming language to develop \texttt{Stegasis} of which I have a good amount of experience with. The virtual File System aspect will be implemented using the \texttt{FUSE} package. A scripting language such as \texttt{Python} or \texttt{MATLAB} may also be used to develop some of the steganalysis tools. Raw \texttt{AVI} Video files for testing purposes can be created using \texttt{VirtualDub}'s video conversion tools.

I intend to implement the project on my own desktop computer (running Ubuntu 14.04.1 as well as Windows 7) due to convenience and accessibility. However, there is no reason why development could not happen on the PWF machines, should this be needed.
Backups will be taken at regular intervals and \texttt{Git}, a revision control system will be used (in conjunction with \texttt{GitHub}) to preserve multiple versions of the project stored both locally and in an offsite location.

\section*{Starting Point}
Steganography shares a number of concepts with Cryptography for which an introductory course (Security I) was given last year. I have read the introductory chapters of Steganography in Digital Media by Jessica Fridrich, a number of generic steganography papers and also a few papers specific to Steganographic File Systems.

I have implemented a simple ``hello world'' \texttt{FUSE} virtual file system in \texttt{C++} to prove the package works as I would expect.

\section*{Substance and Structure of the Project}
The project will consist of the following sections:
\begin{enumerate}
\item Research and investigation into the theoretical aspects of steganography, identifying appropriate embedding algorithms and steganalysis techniques. Investigation into developing a virtual file system and the \texttt{AVI} video format.
\item Design and implementation of \texttt{Stegasis} providing a variety of steganographic embedding algorithms, allowing raw \texttt{AVI} files to be formatted, and the mounted file system to be written to and read from. This section will follow an iterative process wherein each iteration will propose an increasingly secure embedding algorithm and an attempt to develop a suitable steganalysis technique to break it.
\item Evaluation of \texttt{Stegasis} will be based on the following criteria:
    \begin{itemize}
    \item Correctness: \texttt{Stegasis} correctly formats and mounts a provided video file presenting the file system as a logical volume. Files written to the volume should persist between unmounts and subsequent mounts of the same unmodified video file.
    \item Usability: The \texttt{Stegasis} command line tool should be simple and intuative providing useage details for its functionality and helpful error messages.
    \item Performace: The steganographic embedding process should have no noticeable impact on the file system performance i.e. writes to files should not be perceivably slower than a standard HDD\footnote{For example, it takes roughly 2ms to read a 1MB file from a HDD.}.
    \end{itemize}
\end{enumerate}

\section*{Success Criteria}

For the project to be considered a success, \texttt{Stegasis} should provide the following functionality:
\begin{itemize}
\item \texttt{Stegasis} should offer a number of steganographic embedding algorithms.
\item Given a standard raw \texttt{AVI} video file, \texttt{Stegasis} should format\footnote{Format in this case is referring to writing some meta data to the video e.g. which embedding algorithm is being used.} the video such that it can be mounted.
\item Given a formatted video file, \texttt{Stegasis} should be able to mount the video and present a virtual file system at a given mount point.
\item Standard file system operations including listing files, reading a file, writing to a file and deleting a file should be supported within the virtual file system.
\item The above described functionality of \texttt{Stegasis} should operate without noticeable visual impact on the video content.
\end{itemize}

\section*{Extensions}

If there is sufficient time, the following extensions may be attempted:
\begin{itemize}
\item Directory Structure: \texttt{Stegasis} as described only permits files to be created within the root of the virtual file system. It would be beneficial to allow users to create folder structures as you would expect from a standard file system.
\item Audio Usage: \texttt{Stegasis} as described only makes use of video image frames to embed the file system. However, a substantial part of an \texttt{AVI} file may be the audio data. It would be useful to make use of the audio data to increase the steganographic capacity of the proposed embedding algorithms.
\item Video Formats: Unfortunately, raw \texttt{AVI} video is (very) uncommon compared with modern compressed video formats such as \texttt{H.264 (mp4)} it would be very beneficial for \texttt{Stegasis} to operate on a variety of video formats, rather than just raw \texttt{AVI}. However, modern video formats are intricate and complex so this may well be outside the scope of this project.
\item Evaluation of video artifacts: Quantification of ``noticeable visual impact on video content'' via a set of human trials possibly achievable by crowd-sourcing through an online website.
\end{itemize}

\section*{Timetable}
\subsection*{Michaelmas Term}
\begin{itemize}
\item \textbf{\textit{24th October - 6th November (weeks 3-4):}} Research on the theoretical background of steganography including reading relevant sections of textbooks and academic papers.
\item \textbf{\textit{7th November - 20th November (weeks 5-6):}} Investigation of appropriate steganographic embedding algorithms suitable for video files. Investigation of the \texttt{AVI} video format and the \texttt{FUSE} package.
\item \textbf{\textit{21st November - 4th December (weeks 7-8):}} Implementation of \texttt{Stegasis} only offering the simple LSB embedding algorithm and file system functionality.
\end{itemize}

\subsection*{Winter Vacation}
\begin{itemize}
\item \textbf{\textit{5th December - 18th December:}} Implementation of more advanced steganographic embedding techniques and integration of these into \texttt{Stegasis}. Development of steganalysis tools to break proposed embedding schemes.
\item \textbf{\textit{19th December - 1st January:}} Christmas holiday.
\item \textbf{\textit{2nd January - 16th January:}} Continuing work on more advanced steganographic embedding and steganalysis techniques.
\end{itemize}

\subsection*{Lent Term}
\begin{itemize}
\item \textbf{\textit{16th January - 22nd January (week 1):}} Polishing of \texttt{Stegasis} and source code (not yet including extension work) - core project should be finished at this point. Write progress report and prepare for the progress presentation.
\item \textbf{\textit{23rd January - 12th February (weeks 2-4):}} Evaluation of the core project. Identification and implementation of promising extension tasks.
\item \textbf{\textit{13th February - 26th March (weeks 5-10):}} Work on the dissertation write-up, completing a draft for submission to my supervisor.
\item \textbf{\textit{27th March -  23rd April (Easter Vacation):}} Revision of dissertation addressing supervisors comments. Dissertation should be ready to submit by 23rd April.
\end{itemize}

\end{document}
